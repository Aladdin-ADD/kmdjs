!function (n, e) {
    "use strict"; function t(n) { for (var e = {}, t = 0; t < n.length; ++t) e[n[t]] = !0; return e } function r(n, e) { return Array.prototype.slice.call(n, e || 0) } function i(n) { return n.split("") } function o(n, e) { for (var t = e.length; --t >= 0;) if (e[t] == n) return !0; return !1 } function a(n, e) { for (var t = 0, r = e.length; r > t; ++t) if (n(e[t])) return e[t] } function u(n, e) { if (0 >= e) return ""; if (1 == e) return n; var t = u(n, e >> 1); return t += t, 1 & e && (t += n), t } function s(n, e) { Error.call(this, n), this.msg = n, this.defs = e } function c(n, e, t) { n === !0 && (n = {}); var r = n || {}; if (t) for (var i in r) r.hasOwnProperty(i) && !e.hasOwnProperty(i) && s.croak("`" + i + "` is not a supported option", e); for (var i in e) e.hasOwnProperty(i) && (r[i] = n && n.hasOwnProperty(i) ? n[i] : e[i]); return r } function f(n, e) { for (var t in e) e.hasOwnProperty(t) && (n[t] = e[t]); return n } function l() { } function p(n, e) { n.indexOf(e) < 0 && n.push(e) } function d(n, e) { return n.replace(/\{(.+?)\}/g, function (n, t) { return e[t] }) } function h(n, e) { for (var t = n.length; --t >= 0;) n[t] === e && n.splice(t, 1) } function _(n, e) { function t(n, t) { for (var r = [], i = 0, o = 0, a = 0; i < n.length && o < t.length;) r[a++] = e(n[i], t[o]) <= 0 ? n[i++] : t[o++]; return i < n.length && r.push.apply(r, n.slice(i)), o < t.length && r.push.apply(r, t.slice(o)), r } function r(n) { if (n.length <= 1) return n; var e = Math.floor(n.length / 2), i = n.slice(0, e), o = n.slice(e); return i = r(i), o = r(o), t(i, o) } return n.length < 2 ? n.slice() : r(n) } function v(n, e) { return n.filter(function (n) { return e.indexOf(n) < 0 }) } function m(n, e) { return n.filter(function (n) { return e.indexOf(n) >= 0 }) } function g(n) { function e(n) { if (1 == n.length) return t += "return str === " + JSON.stringify(n[0]) + ";"; t += "switch(str){"; for (var e = 0; e < n.length; ++e) t += "case " + JSON.stringify(n[e]) + ":"; t += "return true}return false;" } n instanceof Array || (n = n.split(" ")); var t = "", r = []; n: for (var i = 0; i < n.length; ++i) { for (var o = 0; o < r.length; ++o) if (r[o][0].length == n[i].length) { r[o].push(n[i]); continue n } r.push([n[i]]) } if (r.length > 3) { r.sort(function (n, e) { return e.length - n.length }), t += "switch(str.length){"; for (var i = 0; i < r.length; ++i) { var a = r[i]; t += "case " + a[0].length + ":", e(a) } t += "}" } else e(n); return new Function("str", t) } function b(n, e) { for (var t = n.length; --t >= 0;) if (!e(n[t])) return !1; return !0 } function y() { this._values = {}, this._size = 0 } function A(n, e, t, r) { arguments.length < 4 && (r = L), e = e ? e.split(/\s+/) : []; var i = e; r && r.PROPS && (e = e.concat(r.PROPS)); for (var o = "return function AST_" + n + "(props){ if (props) { ", a = e.length; --a >= 0;) o += "this." + e[a] + " = props." + e[a] + ";"; var u = r && new r; (u && u.initialize || t && t.initialize) && (o += "this.initialize();"), o += "}}"; var s = new Function(o)(); if (u && (s.prototype = u, s.BASE = r), r && r.SUBCLASSES.push(s), s.prototype.CTOR = s, s.PROPS = e || null, s.SELF_PROPS = i, s.SUBCLASSES = [], n && (s.prototype.TYPE = s.TYPE = n), t) for (a in t) t.hasOwnProperty(a) && (/^\$/.test(a) ? s[a.substr(1)] = t[a] : s.prototype[a] = t[a]); return s.DEFMETHOD = function (n, e) { this.prototype[n] = e }, s } function w(n, e) { n.body instanceof W ? n.body._walk(e) : n.body.forEach(function (n) { n._walk(e) }) } function E(n) { this.visit = n, this.stack = [] } function D(n) { return n >= 97 && 122 >= n || n >= 65 && 90 >= n || n >= 170 && Rt.letter.test(String.fromCharCode(n)) } function F(n) { return n >= 48 && 57 >= n } function C(n) { return F(n) || D(n) } function S(n) { return Rt.non_spacing_mark.test(n) || Rt.space_combining_mark.test(n) } function k(n) { return Rt.connector_punctuation.test(n) } function B(n) { return !Ft(n) && /^[a-z_$][a-z0-9_$]*$/i.test(n) } function x(n) { return 36 == n || 95 == n || D(n) } function T(n) { var e = n.charCodeAt(0); return x(e) || F(e) || 8204 == e || 8205 == e || S(n) || k(n) } function $(n) { return /^[a-z_$][a-z0-9_$]*$/i.test(n) } function O(n) { return kt.test(n) ? parseInt(n.substr(2), 16) : Bt.test(n) ? parseInt(n.substr(1), 8) : xt.test(n) ? parseFloat(n) : void 0 } function N(n, e, t, r) { this.message = n, this.line = e, this.col = t, this.pos = r, this.stack = (new Error).stack } function M(n, e, t, r, i) { throw new N(n, t, r, i) } function R(n, e, t) { return n.type == e && (null == t || n.value == t) } function H(n, e, t) { function r() { return D.text.charAt(D.pos) } function i(n, e) { var t = D.text.charAt(D.pos++); if (n && !t) throw Ht; return "\n" == t ? (D.newline_before = D.newline_before || !e, ++D.line, D.col = 0) : ++D.col, t } function o(n) { for (; n-- > 0;) i() } function a(n) { return D.text.substr(D.pos, n.length) == n } function u(n, e) { var t = D.text.indexOf(n, D.pos); if (e && -1 == t) throw Ht; return t } function s() { D.tokline = D.line, D.tokcol = D.col, D.tokpos = D.pos } function c(n, t, r) { D.regex_allowed = "operator" == n && !Pt(t) || "keyword" == n && Ct(t) || "punc" == n && Ot(t), S = "punc" == n && "." == t; var i = { type: n, value: t, line: D.tokline, col: D.tokcol, pos: D.tokpos, endpos: D.pos, nlb: D.newline_before, file: e }; if (!r) { i.comments_before = D.comments_before, D.comments_before = []; for (var o = 0, a = i.comments_before.length; a > o; o++) i.nlb = i.nlb || i.comments_before[o].nlb } return D.newline_before = !1, new V(i) } function f() { for (; $t(r()) ;) i() } function l(n) { for (var e, t = "", o = 0; (e = r()) && n(e, o++) ;) t += i(); return t } function p(n) { M(n, e, D.tokline, D.tokcol, D.tokpos) } function d(n) { var e = !1, t = !1, r = !1, i = "." == n, o = l(function (o, a) { var u = o.charCodeAt(0); switch (u) { case 120: case 88: return r ? !1 : r = !0; case 101: case 69: return r ? !0 : e ? !1 : e = t = !0; case 45: return t || 0 == a && !n; case 43: return t; case t = !1, 46: return i || r || e ? !1 : i = !0 } return C(u) }); n && (o = n + o); var a = O(o); return isNaN(a) ? void p("Invalid syntax: " + o) : c("num", a) } function h(n) { var e = i(!0, n); switch (e.charCodeAt(0)) { case 110: return "\n"; case 114: return "\r"; case 116: return "	"; case 98: return "\b"; case 118: return ""; case 102: return "\f"; case 48: return "\x00"; case 120: return String.fromCharCode(_(2)); case 117: return String.fromCharCode(_(4)); case 10: return ""; default: return e } } function _(n) { for (var e = 0; n > 0; --n) { var t = parseInt(i(!0), 16); isNaN(t) && p("Invalid hex-character pattern in string"), e = e << 4 | t } return e } function v(n) { var e, t = D.regex_allowed, r = u("\n"); return -1 == r ? (e = D.text.substr(D.pos), D.pos = D.text.length) : (e = D.text.substring(D.pos, r), D.pos = r), D.comments_before.push(c(n, e, !0)), D.regex_allowed = t, E() } function m() { for (var n, e, t = !1, o = "", a = !1; null != (n = r()) ;) if (t) "u" != n && p("Expecting UnicodeEscapeSequence -- uXXXX"), n = h(), T(n) || p("Unicode char: " + n.charCodeAt(0) + " is not valid in identifier"), o += n, t = !1; else if ("\\" == n) a = t = !0, i(); else { if (!T(n)) break; o += i() } return Et(o) && a && (e = o.charCodeAt(0).toString(16).toUpperCase(), o = "\\u" + "0000".substr(e.length) + e + o.slice(1)), o } function g(n) { function e(n) { if (!r()) return n; var t = n + r(); return Tt(t) ? (i(), e(t)) : n } return c("operator", e(n || i())) } function b() { switch (i(), r()) { case "/": return i(), v("comment1"); case "*": return i(), B() } return D.regex_allowed ? $("") : g("/") } function y() { return i(), F(r().charCodeAt(0)) ? d(".") : c("punc", ".") } function A() { var n = m(); return S ? c("name", n) : Dt(n) ? c("atom", n) : Et(n) ? Tt(n) ? c("operator", n) : c("keyword", n) : c("name", n) } function w(n, e) { return function (t) { try { return e(t) } catch (r) { if (r !== Ht) throw r; p(n) } } } function E(n) { if (null != n) return $(n); if (f(), s(), t) { if (a("<!--")) return o(4), v("comment3"); if (a("-->") && D.newline_before) return o(3), v("comment4") } var e = r(); if (!e) return c("eof"); var u = e.charCodeAt(0); switch (u) { case 34: case 39: return k(); case 46: return y(); case 47: return b() } return F(u) ? d() : Nt(e) ? c("punc", i()) : St(e) ? g() : 92 == u || x(u) ? A() : void p("Unexpected character '" + e + "'") } var D = { text: n.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ""), filename: e, pos: 0, tokpos: 0, line: 1, tokline: 0, col: 0, tokcol: 0, newline_before: !1, regex_allowed: !1, comments_before: [] }, S = !1, k = w("Unterminated string constant", function () { for (var n = i(), e = ""; ;) { var t = i(!0); if ("\\" == t) { var r = 0, o = null; t = l(function (n) { if (n >= "0" && "7" >= n) { if (!o) return o = n, ++r; if ("3" >= o && 2 >= r) return ++r; if (o >= "4" && 1 >= r) return ++r } return !1 }), t = r > 0 ? String.fromCharCode(parseInt(t, 8)) : h(!0) } else if (t == n) break; e += t } return c("string", e) }), B = w("Unterminated multiline comment", function () { var n = D.regex_allowed, e = u("*/", !0), t = D.text.substring(D.pos, e), r = t.split("\n"), i = r.length; D.pos = e + 2, D.line += i - 1, i > 1 ? D.col = r[i - 1].length : D.col += r[i - 1].length, D.col += 2; var o = D.newline_before = D.newline_before || t.indexOf("\n") >= 0; return D.comments_before.push(c("comment2", t, !0)), D.regex_allowed = n, D.newline_before = o, E() }), $ = w("Unterminated regular expression", function (n) { for (var e, t = !1, r = !1; e = i(!0) ;) if (t) n += "\\" + e, t = !1; else if ("[" == e) r = !0, n += e; else if ("]" == e && r) r = !1, n += e; else { if ("/" == e && !r) break; "\\" == e ? t = !0 : n += e } var o = m(); return c("regexp", new RegExp(n, o)) }); return E.context = function (n) { return n && (D = n), D }, E } function q(n, e) { function t(n, e) { return R(I.token, n, e) } function r() { return I.peeked || (I.peeked = I.input()) } function i() { return I.prev = I.token, I.peeked ? (I.token = I.peeked, I.peeked = null) : I.token = I.input(), I.in_directives = I.in_directives && ("string" == I.token.type || t("punc", ";")), I.token } function o() { return I.prev } function u(n, e, t, r) { var i = I.input.context(); M(n, i.filename, null != e ? e : i.tokline, null != t ? t : i.tokcol, null != r ? r : i.tokpos) } function s(n, e) { u(e, n.line, n.col) } function f(n) { null == n && (n = I.token), s(n, "Unexpected token: " + n.type + " (" + n.value + ")") } function l(n, e) { return t(n, e) ? i() : void s(I.token, "Unexpected token " + I.token.type + " «" + I.token.value + "», expected " + n + " «" + e + "»") } function p(n) { return l("punc", n) } function d() { return !e.strict && (I.token.nlb || t("eof") || t("punc", "}")) } function h() { t("punc", ";") ? i() : d() || f() } function _() { p("("); var n = Be(!0); return p(")"), n } function v(n) { return function () { var e = I.token, t = n(), r = o(); return t.start = e, t.end = r, t } } function m() { (t("operator", "/") || t("operator", "/=")) && (I.peeked = null, I.token = I.input(I.token.value.substr(1))) } function g() { var n = N(at); a(function (e) { return e.name == n.name }, I.labels) && u("Label " + n.name + " defined twice"), p(":"), I.labels.push(n); var e = U(); return I.labels.pop(), e instanceof ee || n.references.forEach(function (e) { e instanceof ye && (e = e.label.start, u("Continue label `" + n.name + "` refers to non-IterationStatement.", e.line, e.col, e.pos)) }), new ne({ body: e, label: n }) } function b(n) { return new G({ body: (n = Be(!0), h(), n) }) } function y(n) { var e, t = null; d() || (t = N(st, !0)), null != t ? (e = a(function (n) { return n.name == t.name }, I.labels), e || u("Undefined label " + t.name), t.thedef = e) : 0 == I.in_loop && u(n.TYPE + " not inside a loop or switch"), h(); var r = new n({ label: t }); return e && e.references.push(r), r } function A() { p("("); var n = null; return !t("punc", ";") && (n = t("keyword", "var") ? (i(), L(!0)) : Be(!0, !0), t("operator", "in")) ? (n instanceof xe && n.definitions.length > 1 && u("Only one variable declaration allowed in for..in loop"), i(), E(n)) : w(n) } function w(n) { p(";"); var e = t("punc", ";") ? null : Be(!0); p(";"); var r = t("punc", ")") ? null : Be(!0); return p(")"), new oe({ init: n, condition: e, step: r, body: z(U) }) } function E(n) { var e = n instanceof xe ? n.definitions[0].name : null, t = Be(!0); return p(")"), new ae({ init: n, name: e, object: t, body: z(U) }) } function D() { var n = _(), e = U(), r = null; return t("keyword", "else") && (i(), r = U()), new Ae({ condition: n, body: e, alternative: r }) } function F() { p("{"); for (var n = []; !t("punc", "}") ;) t("eof") && f(), n.push(U()); return i(), n } function C() { p("{"); for (var n, e = [], r = null, a = null; !t("punc", "}") ;) t("eof") && f(), t("keyword", "case") ? (a && (a.end = o()), r = [], a = new Fe({ start: (n = I.token, i(), n), expression: Be(!0), body: r }), e.push(a), p(":")) : t("keyword", "default") ? (a && (a.end = o()), r = [], a = new De({ start: (n = I.token, i(), p(":"), n), body: r }), e.push(a)) : (r || f(), r.push(U())); return a && (a.end = o()), i(), e } function S() { var n = F(), e = null, r = null; if (t("keyword", "catch")) { var a = I.token; i(), p("("); var s = N(ot); p(")"), e = new Se({ start: a, argname: s, body: F(), end: o() }) } if (t("keyword", "finally")) { var a = I.token; i(), r = new ke({ start: a, body: F(), end: o() }) } return e || r || u("Missing catch/finally blocks"), new Ce({ body: n, bcatch: e, bfinally: r }) } function k(n, e) { for (var r = []; r.push(new $e({ start: I.token, name: N(e ? et : nt), value: t("operator", "=") ? (i(), Be(!1, n)) : null, end: o() })), t("punc", ",") ;) i(); return r } function B() { var n, e = I.token; switch (e.type) { case "name": case "keyword": n = O(ut); break; case "num": n = new pt({ start: e, end: e, value: e.value }); break; case "string": n = new lt({ start: e, end: e, value: e.value }); break; case "regexp": n = new dt({ start: e, end: e, value: e.value }); break; case "atom": switch (e.value) { case "false": n = new At({ start: e, end: e }); break; case "true": n = new wt({ start: e, end: e }); break; case "null": n = new _t({ start: e, end: e }) } } return i(), n } function x(n, e, r) { for (var o = !0, a = []; !t("punc", n) && (o ? o = !1 : p(","), !e || !t("punc", n)) ;) a.push(t("punc", ",") && r ? new gt({ start: I.token, end: I.token }) : Be(!1)); return i(), a } function T() { var n = I.token; switch (i(), n.type) { case "num": case "string": case "name": case "operator": case "keyword": case "atom": return n.value; default: f() } } function $() { var n = I.token; switch (i(), n.type) { case "name": case "operator": case "keyword": case "atom": return n.value; default: f() } } function O(n) { var e = I.token.value; return new ("this" == e ? ct : n)({ name: String(e), start: I.token, end: I.token }) } function N(n, e) { if (!t("name")) return e || u("Name expected"), null; var r = O(n); return i(), r } function q(n, e, t) { return "++" != e && "--" != e || j(t) || u("Invalid use of " + e + " operator"), new n({ operator: e, expression: t }) } function P(n) { return _e(he(!0), 0, n) } function j(n) { return e.strict ? n instanceof ct ? !1 : n instanceof Re || n instanceof Je : !0 } function z(n) { ++I.in_loop; var e = n(); return --I.in_loop, e } e = c(e, { strict: !1, filename: null, toplevel: null, expression: !1, html5_comments: !0 }); var I = { input: "string" == typeof n ? H(n, e.filename, e.html5_comments) : n, token: null, prev: null, peeked: null, in_function: 0, in_directives: !0, in_loop: 0, labels: [] }; I.token = i(); var U = v(function () { var n; switch (m(), I.token.type) { case "string": var e = I.in_directives, a = b(); return e && a.body instanceof lt && !t("punc", ",") ? new X({ value: a.body.value }) : a; case "num": case "regexp": case "operator": case "atom": return b(); case "name": return R(r(), "punc", ":") ? g() : b(); case "punc": switch (I.token.value) { case "{": return new J({ start: I.token, body: F(), end: o() }); case "[": case "(": return b(); case ";": return i(), new Q; default: f() } case "keyword": switch (n = I.token.value, i(), n) { case "break": return y(be); case "continue": return y(ye); case "debugger": return h(), new Y; case "do": return new re({ body: z(U), condition: (l("keyword", "while"), n = _(), h(), n) }); case "while": return new ie({ condition: _(), body: z(U) }); case "for": return A(); case "function": return V(de); case "if": return D(); case "return": return 0 == I.in_function && u("'return' outside of function"), new ve({ value: t("punc", ";") ? (i(), null) : d() ? null : (n = Be(!0), h(), n) }); case "switch": return new we({ expression: _(), body: z(C) }); case "throw": return I.token.nlb && u("Illegal newline after 'throw'"), new me({ value: (n = Be(!0), h(), n) }); case "try": return S(); case "var": return n = L(), h(), n; case "const": return n = W(), h(), n; case "with": return new ue({ expression: _(), body: U() }); default: f() } } }), V = function (n) { var e = n === de, r = t("name") ? N(e ? rt : it) : null; return e && !r && f(), p("("), new n({ name: r, argnames: function (n, e) { for (; !t("punc", ")") ;) n ? n = !1 : p(","), e.push(N(tt)); return i(), e }(!0, []), body: function (n, e) { ++I.in_function, I.in_directives = !0, I.in_loop = 0, I.labels = []; var t = F(); return --I.in_function, I.in_loop = n, I.labels = e, t }(I.in_loop, I.labels) }) }, L = function (n) { return new xe({ start: o(), definitions: k(n, !1), end: o() }) }, W = function () { return new Te({ start: o(), definitions: k(!1, !0), end: o() }) }, K = function () { var n = I.token; l("operator", "new"); var e, r = Z(!1); return t("punc", "(") ? (i(), e = x(")")) : e = [], fe(new Ne({ start: n, expression: r, args: e, end: o() }), !0) }, Z = function (n) { if (t("operator", "new")) return K(); var e = I.token; if (t("punc")) { switch (e.value) { case "(": i(); var r = Be(!0); return r.start = e, r.end = I.token, p(")"), fe(r, n); case "[": return fe(te(), n); case "{": return fe(se(), n) } f() } if (t("keyword", "function")) { i(); var a = V(pe); return a.start = e, a.end = o(), fe(a, n) } return Ut[I.token.type] ? fe(B(), n) : void f() }, te = v(function () { return p("["), new Le({ elements: x("]", !e.strict, !0) }) }), se = v(function () { p("{"); for (var n = !0, r = []; !t("punc", "}") && (n ? n = !1 : p(","), e.strict || !t("punc", "}")) ;) { var a = I.token, u = a.type, s = T(); if ("name" == u && !t("punc", ":")) { if ("get" == s) { r.push(new Ke({ start: a, key: B(), value: V(le), end: o() })); continue } if ("set" == s) { r.push(new Ge({ start: a, key: B(), value: V(le), end: o() })); continue } } p(":"), r.push(new Xe({ start: a, key: s, value: Be(!1), end: o() })) } return i(), new We({ properties: r }) }), fe = function (n, e) { var r = n.start; if (t("punc", ".")) return i(), fe(new He({ start: r, expression: n, property: $(), end: o() }), e); if (t("punc", "[")) { i(); var a = Be(!0); return p("]"), fe(new qe({ start: r, expression: n, property: a, end: o() }), e) } return e && t("punc", "(") ? (i(), fe(new Oe({ start: r, expression: n, args: x(")"), end: o() }), !0)) : n }, he = function (n) { var e = I.token; if (t("operator") && qt(e.value)) { i(), m(); var r = q(je, e.value, he(n)); return r.start = e, r.end = o(), r } for (var a = Z(n) ; t("operator") && Pt(I.token.value) && !I.token.nlb;) a = q(ze, I.token.value, a), a.start = e, a.end = I.token, i(); return a }, _e = function (n, e, r) { var o = t("operator") ? I.token.value : null; "in" == o && r && (o = null); var a = null != o ? zt[o] : null; if (null != a && a > e) { i(); var u = _e(he(!0), a, r); return _e(new Ie({ start: n.start, left: n, operator: o, right: u, end: u.end }), e, r) } return n }, ge = function (n) { var e = I.token, r = P(n); if (t("operator", "?")) { i(); var a = Be(!1); return p(":"), new Ue({ start: e, condition: r, consequent: a, alternative: Be(!1, n), end: o() }) } return r }, Ee = function (n) { var e = I.token, r = ge(n), a = I.token.value; if (t("operator") && jt(a)) { if (j(r)) return i(), new Ve({ start: e, left: r, operator: a, right: Ee(n), end: o() }); u("Invalid assignment") } return r }, Be = function (n, e) { var o = I.token, a = Ee(e); return n && t("punc", ",") ? (i(), new Me({ start: o, car: a, cdr: Be(!0, e), end: r() })) : a }; return e.expression ? Be(!0) : function () { for (var n = I.token, r = []; !t("eof") ;) r.push(U()); var i = o(), a = e.toplevel; return a ? (a.body = a.body.concat(r), a.end = i) : a = new ce({ start: n, body: r, end: i }), a }() } function P(n, e) { E.call(this), this.before = n, this.after = e } function j(n, e, t) { this.name = t.name, this.orig = [t], this.scope = n, this.references = [], this.global = !1, this.mangled_name = null, this.undeclared = !1, this.constant = !1, this.index = e } function z(n) { function e(n, e) { return n.replace(/[\u0080-\uffff]/g, function (n) { var t = n.charCodeAt(0).toString(16); if (t.length <= 2 && !e) { for (; t.length < 2;) t = "0" + t; return "\\x" + t } for (; t.length < 4;) t = "0" + t; return "\\u" + t }) } function t(t) { var r = 0, i = 0; return t = t.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function (n) { switch (n) { case "\\": return "\\\\"; case "\b": return "\\b"; case "\f": return "\\f"; case "\n": return "\\n"; case "\r": return "\\r"; case "\u2028": return "\\u2028"; case "\u2029": return "\\u2029"; case '"': return ++r, '"'; case "'": return ++i, "'"; case "\x00": return "\\x00" } return n }), n.ascii_only && (t = e(t)), r > i ? "'" + t.replace(/\x27/g, "\\'") + "'" : '"' + t.replace(/\x22/g, '\\"') + '"' } function r(e) { var r = t(e); return n.inline_script && (r = r.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1")), r } function i(t) { return t = t.toString(), n.ascii_only && (t = e(t, !0)), t } function o(e) { return u(" ", n.indent_start + A - e * n.indent_level) } function a() { return k.charAt(k.length - 1) } function s() { n.max_line_len && w > n.max_line_len && f("\n") } function f(e) { e = String(e); var t = e.charAt(0); if (S && (t && !(";}".indexOf(t) < 0) || /[;]$/.test(k) || (n.semicolons || B(t) ? (F += ";", w++, D++) : (F += "\n", D++, E++, w = 0), n.beautify || (C = !1)), S = !1, s()), !n.beautify && n.preserve_line && H[H.length - 1]) for (var r = H[H.length - 1].start.line; r > E;) F += "\n", D++, E++, w = 0, C = !1; if (C) { var i = a(); (T(i) && (T(t) || "\\" == t) || /^[\+\-\/]$/.test(t) && t == i) && (F += " ", w++, D++), C = !1 } var o = e.split(/\r?\n/), u = o.length - 1; E += u, 0 == u ? w += o[u].length : w = o[u].length, D += e.length, k = e, F += e } function p() { S = !1, f(";") } function d() { return A + n.indent_level } function h(n) { var e; return f("{"), N(), O(d(), function () { e = n() }), $(), f("}"), e } function _(n) { f("("); var e = n(); return f(")"), e } function v(n) { f("["); var e = n(); return f("]"), e } function m() { f(","), x() } function b() { f(":"), n.space_colon && x() } function y() { return F } n = c(n, { indent_start: 0, indent_level: 4, quote_keys: !1, space_colon: !0, ascii_only: !1, unescape_regexps: !1, inline_script: !1, width: 80, max_line_len: 32e3, beautify: !1, source_map: null, bracketize: !1, semicolons: !0, comments: !1, preserve_line: !1, screw_ie8: !1, preamble: null }, !0); var A = 0, w = 0, E = 1, D = 0, F = "", C = !1, S = !1, k = null, B = g("( [ + * / - , ."), x = n.beautify ? function () { f(" ") } : function () { C = !0 }, $ = n.beautify ? function (e) { n.beautify && f(o(e ? .5 : 0)) } : l, O = n.beautify ? function (n, e) { n === !0 && (n = d()); var t = A; A = n; var r = e(); return A = t, r } : function (n, e) { return e() }, N = n.beautify ? function () { f("\n") } : l, M = n.beautify ? function () { f(";") } : function () { S = !0 }, R = n.source_map ? function (e, t) { try { e && n.source_map.add(e.file || "?", E, w, e.line, e.col, t || "name" != e.type ? t : e.value) } catch (r) { L.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", { file: e.file, line: e.line, col: e.col, cline: E, ccol: w, name: t || "" }) } } : l; n.preamble && f(n.preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n")); var H = []; return { get: y, toString: y, indent: $, indentation: function () { return A }, current_width: function () { return w - A }, should_break: function () { return n.width && this.current_width() >= n.width }, newline: N, print: f, space: x, comma: m, colon: b, last: function () { return k }, semicolon: M, force_semicolon: p, to_ascii: e, print_name: function (n) { f(i(n)) }, print_string: function (n) { f(r(n)) }, next_indent: d, with_indent: O, with_block: h, with_parens: _, with_square: v, add_mapping: R, option: function (e) { return n[e] }, line: function () { return E }, col: function () { return w }, pos: function () { return D }, push_node: function (n) { H.push(n) }, pop_node: function () { return H.pop() }, stack: function () { return H }, parent: function (n) { return H[H.length - 2 - (n || 0)] } } } function I(n, e) { return this instanceof I ? (P.call(this, this.before, this.after), void (this.options = c(n, { sequences: !e, properties: !e, dead_code: !e, drop_debugger: !e, unsafe: !1, unsafe_comps: !1, conditionals: !e, comparisons: !e, evaluate: !e, booleans: !e, loops: !e, unused: !e, hoist_funs: !e, keep_fargs: !1, hoist_vars: !1, if_return: !e, join_vars: !e, cascade: !e, side_effects: !e, pure_getters: !1, pure_funcs: null, negate_iife: !e, screw_ie8: !1, drop_console: !1, angular: !1, warnings: !0, global_defs: {} }, !0))) : new I(n, e) } e.UglifyJS = n, s.prototype = Object.create(Error.prototype), s.prototype.constructor = s, s.croak = function (n, e) { throw new s(n, e) }; var U = function () { function n(n, o, a) { function u() { var u = o(n[s], s), l = u instanceof r; return l && (u = u.v), u instanceof e ? (u = u.v, u instanceof t ? f.push.apply(f, a ? u.v.slice().reverse() : u.v) : f.push(u)) : u !== i && (u instanceof t ? c.push.apply(c, a ? u.v.slice().reverse() : u.v) : c.push(u)), l } var s, c = [], f = []; if (n instanceof Array) if (a) { for (s = n.length; --s >= 0 && !u() ;); c.reverse(), f.reverse() } else for (s = 0; s < n.length && !u() ; ++s); else for (s in n) if (n.hasOwnProperty(s) && u()) break; return f.concat(c) } function e(n) { this.v = n } function t(n) { this.v = n } function r(n) { this.v = n } n.at_top = function (n) { return new e(n) }, n.splice = function (n) { return new t(n) }, n.last = function (n) { return new r(n) }; var i = n.skip = {}; return n }(); y.prototype = { set: function (n, e) { return this.has(n) || ++this._size, this._values["$" + n] = e, this }, add: function (n, e) { return this.has(n) ? this.get(n).push(e) : this.set(n, [e]), this }, get: function (n) { return this._values["$" + n] }, del: function (n) { return this.has(n) && (--this._size, delete this._values["$" + n]), this }, has: function (n) { return "$" + n in this._values }, each: function (n) { for (var e in this._values) n(this._values[e], e.substr(1)) }, size: function () { return this._size }, map: function (n) { var e = []; for (var t in this._values) e.push(n(this._values[t], t.substr(1))); return e } }; var V = A("Token", "type value line col pos endpos nlb comments_before file", {}, null), L = A("Node", "start end", { clone: function () { return new this.CTOR(this) }, $documentation: "Base class of all AST nodes", $propdoc: { start: "[AST_Token] The first token of this node", end: "[AST_Token] The last token of this node" }, _walk: function (n) { return n._visit(this) }, walk: function (n) { return this._walk(n) } }, null); L.warn_function = null, L.warn = function (n, e) { L.warn_function && L.warn_function(d(n, e)) }; var W = A("Statement", null, { $documentation: "Base class of all statements" }), Y = A("Debugger", null, { $documentation: "Represents a debugger statement" }, W), X = A("Directive", "value scope", { $documentation: 'Represents a directive, like "use strict";', $propdoc: { value: "[string] The value of this directive as a plain string (it's not an AST_String!)", scope: "[AST_Scope/S] The scope that this directive affects" } }, W), G = A("SimpleStatement", "body", { $documentation: "A statement consisting of an expression, i.e. a = 1 + 2", $propdoc: { body: "[AST_Node] an expression node (should not be instanceof AST_Statement)" }, _walk: function (n) { return n._visit(this, function () { this.body._walk(n) }) } }, W), K = A("Block", "body", { $documentation: "A body of statements (usually bracketed)", $propdoc: { body: "[AST_Statement*] an array of statements" }, _walk: function (n) { return n._visit(this, function () { w(this, n) }) } }, W), J = A("BlockStatement", null, { $documentation: "A block statement" }, K), Q = A("EmptyStatement", null, { $documentation: "The empty statement (empty block or simply a semicolon)", _walk: function (n) { return n._visit(this) } }, W), Z = A("StatementWithBody", "body", { $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`", $propdoc: { body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement" }, _walk: function (n) { return n._visit(this, function () { this.body._walk(n) }) } }, W), ne = A("LabeledStatement", "label", { $documentation: "Statement with a label", $propdoc: { label: "[AST_Label] a label definition" }, _walk: function (n) { return n._visit(this, function () { this.label._walk(n), this.body._walk(n) }) } }, Z), ee = A("IterationStatement", null, { $documentation: "Internal class.  All loops inherit from it." }, Z), te = A("DWLoop", "condition", { $documentation: "Base class for do/while statements", $propdoc: { condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement" }, _walk: function (n) { return n._visit(this, function () { this.condition._walk(n), this.body._walk(n) }) } }, ee), re = A("Do", null, { $documentation: "A `do` statement" }, te), ie = A("While", null, { $documentation: "A `while` statement" }, te), oe = A("For", "init condition step", { $documentation: "A `for` statement", $propdoc: { init: "[AST_Node?] the `for` initialization code, or null if empty", condition: "[AST_Node?] the `for` termination clause, or null if empty", step: "[AST_Node?] the `for` update clause, or null if empty" }, _walk: function (n) { return n._visit(this, function () { this.init && this.init._walk(n), this.condition && this.condition._walk(n), this.step && this.step._walk(n), this.body._walk(n) }) } }, ee), ae = A("ForIn", "init name object", { $documentation: "A `for ... in` statement", $propdoc: { init: "[AST_Node] the `for/in` initialization code", name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var", object: "[AST_Node] the object that we're looping through" }, _walk: function (n) { return n._visit(this, function () { this.init._walk(n), this.object._walk(n), this.body._walk(n) }) } }, ee), ue = A("With", "expression", { $documentation: "A `with` statement", $propdoc: { expression: "[AST_Node] the `with` expression" }, _walk: function (n) { return n._visit(this, function () { this.expression._walk(n), this.body._walk(n) }) } }, Z), se = A("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", { $documentation: "Base class for all statements introducing a lexical scope", $propdoc: { directives: "[string*/S] an array of directives declared in this scope", variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope", functions: "[Object/S] like `variables`, but only lists function declarations", uses_with: "[boolean/S] tells whether this scope uses the `with` statement", uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`", parent_scope: "[AST_Scope?/S] link to the parent scope", enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes", cname: "[integer/S] current index for mangling variables (used internally by the mangler)" } }, K), ce = A("Toplevel", "globals", { $documentation: "The toplevel scope", $propdoc: { globals: "[Object/S] a map of name -> SymbolDef for all undeclared names" }, wrap_enclose: function (n) { var e = this, t = [], r = []; n.forEach(function (n) { var e = n.lastIndexOf(":"); t.push(n.substr(0, e)), r.push(n.substr(e + 1)) }); var i = "(function(" + r.join(",") + "){ '$ORIG'; })(" + t.join(",") + ")"; return i = q(i), i = i.transform(new P(function (n) { return n instanceof X && "$ORIG" == n.value ? U.splice(e.body) : void 0 })) }, wrap_commonjs: function (n, e) { var t = this, r = []; e && (t.figure_out_scope(), t.walk(new E(function (n) { n instanceof Ze && n.definition().global && (a(function (e) { return e.name == n.name }, r) || r.push(n)) }))); var i = "(function(exports, global){ global['" + n + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))"; return i = q(i), i = i.transform(new P(function (n) { if (n instanceof G && (n = n.body, n instanceof lt)) switch (n.getValue()) { case "$ORIG": return U.splice(t.body); case "$EXPORTS": var e = []; return r.forEach(function (n) { e.push(new G({ body: new Ve({ left: new qe({ expression: new ut({ name: "exports" }), property: new lt({ value: n.name }) }), operator: "=", right: new ut(n) }) })) }), U.splice(e) } })) } }, se), fe = A("Lambda", "name argnames uses_arguments", { $documentation: "Base class for functions", $propdoc: { name: "[AST_SymbolDeclaration?] the name of this function", argnames: "[AST_SymbolFunarg*] array of function arguments", uses_arguments: "[boolean/S] tells whether this function accesses the arguments array" }, _walk: function (n) { return n._visit(this, function () { this.name && this.name._walk(n), this.argnames.forEach(function (e) { e._walk(n) }), w(this, n) }) } }, se), le = A("Accessor", null, { $documentation: "A setter/getter function.  The `name` property is always null." }, fe), pe = A("Function", null, { $documentation: "A function expression" }, fe), de = A("Defun", null, { $documentation: "A function definition" }, fe), he = A("Jump", null, { $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)" }, W), _e = A("Exit", "value", { $documentation: "Base class for “exits” (`return` and `throw`)", $propdoc: { value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return" }, _walk: function (n) { return n._visit(this, this.value && function () { this.value._walk(n) }) } }, he), ve = A("Return", null, { $documentation: "A `return` statement" }, _e), me = A("Throw", null, { $documentation: "A `throw` statement" }, _e), ge = A("LoopControl", "label", { $documentation: "Base class for loop control statements (`break` and `continue`)", $propdoc: { label: "[AST_LabelRef?] the label, or null if none" }, _walk: function (n) { return n._visit(this, this.label && function () { this.label._walk(n) }) } }, he), be = A("Break", null, { $documentation: "A `break` statement" }, ge), ye = A("Continue", null, { $documentation: "A `continue` statement" }, ge), Ae = A("If", "condition alternative", { $documentation: "A `if` statement", $propdoc: { condition: "[AST_Node] the `if` condition", alternative: "[AST_Statement?] the `else` part, or null if not present" }, _walk: function (n) { return n._visit(this, function () { this.condition._walk(n), this.body._walk(n), this.alternative && this.alternative._walk(n) }) } }, Z), we = A("Switch", "expression", { $documentation: "A `switch` statement", $propdoc: { expression: "[AST_Node] the `switch` “discriminant”" }, _walk: function (n) { return n._visit(this, function () { this.expression._walk(n), w(this, n) }) } }, K), Ee = A("SwitchBranch", null, { $documentation: "Base class for `switch` branches" }, K), De = A("Default", null, { $documentation: "A `default` switch branch" }, Ee), Fe = A("Case", "expression", { $documentation: "A `case` switch branch", $propdoc: { expression: "[AST_Node] the `case` expression" }, _walk: function (n) { return n._visit(this, function () { this.expression._walk(n), w(this, n) }) } }, Ee), Ce = A("Try", "bcatch bfinally", { $documentation: "A `try` statement", $propdoc: { bcatch: "[AST_Catch?] the catch block, or null if not present", bfinally: "[AST_Finally?] the finally block, or null if not present" }, _walk: function (n) { return n._visit(this, function () { w(this, n), this.bcatch && this.bcatch._walk(n), this.bfinally && this.bfinally._walk(n) }) } }, K), Se = A("Catch", "argname", { $documentation: "A `catch` node; only makes sense as part of a `try` statement", $propdoc: { argname: "[AST_SymbolCatch] symbol for the exception" }, _walk: function (n) { return n._visit(this, function () { this.argname._walk(n), w(this, n) }) } }, K), ke = A("Finally", null, { $documentation: "A `finally` node; only makes sense as part of a `try` statement" }, K), Be = A("Definitions", "definitions", { $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)", $propdoc: { definitions: "[AST_VarDef*] array of variable definitions" }, _walk: function (n) { return n._visit(this, function () { this.definitions.forEach(function (e) { e._walk(n) }) }) } }, W), xe = A("Var", null, { $documentation: "A `var` statement" }, Be), Te = A("Const", null, { $documentation: "A `const` statement" }, Be), $e = A("VarDef", "name value", {
        $documentation: "A variable declaration; only appears in a AST_Definitions node", $propdoc: { name: "[AST_SymbolVar|AST_SymbolConst] name of the variable", value: "[AST_Node?] initializer, or null of there's no initializer" }, _walk: function (n) {
            return n._visit(this, function () {
                this.name._walk(n), this.value && this.value._walk(n)
            })
        }
    }), Oe = A("Call", "expression args", { $documentation: "A function call expression", $propdoc: { expression: "[AST_Node] expression to invoke as function", args: "[AST_Node*] array of arguments" }, _walk: function (n) { return n._visit(this, function () { this.expression._walk(n), this.args.forEach(function (e) { e._walk(n) }) }) } }), Ne = A("New", null, { $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties" }, Oe), Me = A("Seq", "car cdr", { $documentation: "A sequence expression (two comma-separated expressions)", $propdoc: { car: "[AST_Node] first element in sequence", cdr: "[AST_Node] second element in sequence" }, $cons: function (n, e) { var t = new Me(n); return t.car = n, t.cdr = e, t }, $from_array: function (n) { if (0 == n.length) return null; if (1 == n.length) return n[0].clone(); for (var e = null, t = n.length; --t >= 0;) e = Me.cons(n[t], e); for (var r = e; r;) { if (r.cdr && !r.cdr.cdr) { r.cdr = r.cdr.car; break } r = r.cdr } return e }, to_array: function () { for (var n = this, e = []; n;) { if (e.push(n.car), n.cdr && !(n.cdr instanceof Me)) { e.push(n.cdr); break } n = n.cdr } return e }, add: function (n) { for (var e = this; e;) { if (!(e.cdr instanceof Me)) { var t = Me.cons(e.cdr, n); return e.cdr = t } e = e.cdr } }, _walk: function (n) { return n._visit(this, function () { this.car._walk(n), this.cdr && this.cdr._walk(n) }) } }), Re = A("PropAccess", "expression property", { $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`', $propdoc: { expression: "[AST_Node] the “container” expression", property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node" } }), He = A("Dot", null, { $documentation: "A dotted property access expression", _walk: function (n) { return n._visit(this, function () { this.expression._walk(n) }) } }, Re), qe = A("Sub", null, { $documentation: 'Index-style property access, i.e. `a["foo"]`', _walk: function (n) { return n._visit(this, function () { this.expression._walk(n), this.property._walk(n) }) } }, Re), Pe = A("Unary", "operator expression", { $documentation: "Base class for unary expressions", $propdoc: { operator: "[string] the operator", expression: "[AST_Node] expression that this unary operator applies to" }, _walk: function (n) { return n._visit(this, function () { this.expression._walk(n) }) } }), je = A("UnaryPrefix", null, { $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`" }, Pe), ze = A("UnaryPostfix", null, { $documentation: "Unary postfix expression, i.e. `i++`" }, Pe), Ie = A("Binary", "left operator right", { $documentation: "Binary expression, i.e. `a + b`", $propdoc: { left: "[AST_Node] left-hand side expression", operator: "[string] the operator", right: "[AST_Node] right-hand side expression" }, _walk: function (n) { return n._visit(this, function () { this.left._walk(n), this.right._walk(n) }) } }), Ue = A("Conditional", "condition consequent alternative", { $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`", $propdoc: { condition: "[AST_Node]", consequent: "[AST_Node]", alternative: "[AST_Node]" }, _walk: function (n) { return n._visit(this, function () { this.condition._walk(n), this.consequent._walk(n), this.alternative._walk(n) }) } }), Ve = A("Assign", null, { $documentation: "An assignment expression — `a = b + 5`" }, Ie), Le = A("Array", "elements", { $documentation: "An array literal", $propdoc: { elements: "[AST_Node*] array of elements" }, _walk: function (n) { return n._visit(this, function () { this.elements.forEach(function (e) { e._walk(n) }) }) } }), We = A("Object", "properties", { $documentation: "An object literal", $propdoc: { properties: "[AST_ObjectProperty*] array of properties" }, _walk: function (n) { return n._visit(this, function () { this.properties.forEach(function (e) { e._walk(n) }) }) } }), Ye = A("ObjectProperty", "key value", { $documentation: "Base class for literal object properties", $propdoc: { key: "[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST_Node.", value: "[AST_Node] property value.  For setters and getters this is an AST_Function." }, _walk: function (n) { return n._visit(this, function () { this.value._walk(n) }) } }), Xe = A("ObjectKeyVal", null, { $documentation: "A key: value object property" }, Ye), Ge = A("ObjectSetter", null, { $documentation: "An object setter property" }, Ye), Ke = A("ObjectGetter", null, { $documentation: "An object getter property" }, Ye), Je = A("Symbol", "scope name thedef", { $propdoc: { name: "[string] name of this symbol", scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)", thedef: "[SymbolDef/S] the definition of this symbol" }, $documentation: "Base class for all symbols" }), Qe = A("SymbolAccessor", null, { $documentation: "The name of a property accessor (setter/getter function)" }, Je), Ze = A("SymbolDeclaration", "init", { $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)", $propdoc: { init: "[AST_Node*/S] array of initializers for this declaration." } }, Je), nt = A("SymbolVar", null, { $documentation: "Symbol defining a variable" }, Ze), et = A("SymbolConst", null, { $documentation: "A constant declaration" }, Ze), tt = A("SymbolFunarg", null, { $documentation: "Symbol naming a function argument" }, nt), rt = A("SymbolDefun", null, { $documentation: "Symbol defining a function" }, Ze), it = A("SymbolLambda", null, { $documentation: "Symbol naming a function expression" }, Ze), ot = A("SymbolCatch", null, { $documentation: "Symbol naming the exception in catch" }, Ze), at = A("Label", "references", { $documentation: "Symbol naming a label (declaration)", $propdoc: { references: "[AST_LoopControl*] a list of nodes referring to this label" }, initialize: function () { this.references = [], this.thedef = this } }, Je), ut = A("SymbolRef", null, { $documentation: "Reference to some symbol (not definition/declaration)" }, Je), st = A("LabelRef", null, { $documentation: "Reference to a label symbol" }, Je), ct = A("This", null, { $documentation: "The `this` symbol" }, Je), ft = A("Constant", null, { $documentation: "Base class for all constants", getValue: function () { return this.value } }), lt = A("String", "value", { $documentation: "A string literal", $propdoc: { value: "[string] the contents of this string" } }, ft), pt = A("Number", "value", { $documentation: "A number literal", $propdoc: { value: "[number] the numeric value" } }, ft), dt = A("RegExp", "value", { $documentation: "A regexp literal", $propdoc: { value: "[RegExp] the actual regexp" } }, ft), ht = A("Atom", null, { $documentation: "Base class for atoms" }, ft), _t = A("Null", null, { $documentation: "The `null` atom", value: null }, ht), vt = A("NaN", null, { $documentation: "The impossible value", value: 0 / 0 }, ht), mt = A("Undefined", null, { $documentation: "The `undefined` value", value: void 0 }, ht), gt = A("Hole", null, { $documentation: "A hole in an array", value: void 0 }, ht), bt = A("Infinity", null, { $documentation: "The `Infinity` value", value: 1 / 0 }, ht), yt = A("Boolean", null, { $documentation: "Base class for booleans" }, ht), At = A("False", null, { $documentation: "The `false` atom", value: !1 }, yt), wt = A("True", null, { $documentation: "The `true` atom", value: !0 }, yt); E.prototype = { _visit: function (n, e) { this.stack.push(n); var t = this.visit(n, e ? function () { e.call(n) } : l); return !t && e && e.call(n), this.stack.pop(), t }, parent: function (n) { return this.stack[this.stack.length - 2 - (n || 0)] }, push: function (n) { this.stack.push(n) }, pop: function () { return this.stack.pop() }, self: function () { return this.stack[this.stack.length - 1] }, find_parent: function (n) { for (var e = this.stack, t = e.length; --t >= 0;) { var r = e[t]; if (r instanceof n) return r } }, has_directive: function (n) { return this.find_parent(se).has_directive(n) }, in_boolean_context: function () { for (var n = this.stack, e = n.length, t = n[--e]; e > 0;) { var r = n[--e]; if (r instanceof Ae && r.condition === t || r instanceof Ue && r.condition === t || r instanceof te && r.condition === t || r instanceof oe && r.condition === t || r instanceof je && "!" == r.operator && r.expression === t) return !0; if (!(r instanceof Ie) || "&&" != r.operator && "||" != r.operator) return !1; t = r } }, loopcontrol_target: function (n) { var e = this.stack; if (n) for (var t = e.length; --t >= 0;) { var r = e[t]; if (r instanceof ne && r.label.name == n.name) return r.body } else for (var t = e.length; --t >= 0;) { var r = e[t]; if (r instanceof we || r instanceof ee) return r } } }; var Et = "break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with", Dt = "false null true", Ft = "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile yield " + Dt + " " + Et, Ct = "return new delete throw else case"; Et = g(Et), Ft = g(Ft), Ct = g(Ct), Dt = g(Dt); var St = g(i("+-*&%=<>!?|~^")), kt = /^0x[0-9a-f]+$/i, Bt = /^0[0-7]+$/, xt = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i, Tt = g(["in", "instanceof", "typeof", "new", "void", "delete", "++", "--", "+", "-", "!", "~", "&", "|", "^", "*", "/", "%", ">>", "<<", ">>>", "<", ">", "<=", ">=", "==", "===", "!=", "!==", "?", "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=", "&&", "||"]), $t = g(i("  \n\r	\f​᠎             　")), Ot = g(i("[{(,.;:")), Nt = g(i("[]{}(),;:")), Mt = g(i("gmsiy")), Rt = { letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"), non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"), space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"), connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]") }; N.prototype.toString = function () { return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")\n\n" + this.stack }; var Ht = {}, qt = g(["typeof", "void", "delete", "--", "++", "!", "~", "-", "+"]), Pt = g(["--", "++"]), jt = g(["=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="]), zt = function (n, e) { for (var t = 0; t < n.length; ++t) for (var r = n[t], i = 0; i < r.length; ++i) e[r[i]] = t + 1; return e }([["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"]], {}), It = t(["for", "do", "while", "switch"]), Ut = t(["atom", "num", "string", "regexp", "name"]); P.prototype = new E, function (n) { function e(e, t) { e.DEFMETHOD("transform", function (e, r) { var i, o; return e.push(this), e.before && (i = e.before(this, t, r)), i === n && (e.after ? (e.stack[e.stack.length - 1] = i = this.clone(), t(i, e), o = e.after(i, r), o !== n && (i = o)) : (i = this, t(i, e))), e.pop(), i }) } function t(n, e) { return U(n, function (n) { return n.transform(e, !0) }) } e(L, l), e(ne, function (n, e) { n.label = n.label.transform(e), n.body = n.body.transform(e) }), e(G, function (n, e) { n.body = n.body.transform(e) }), e(K, function (n, e) { n.body = t(n.body, e) }), e(te, function (n, e) { n.condition = n.condition.transform(e), n.body = n.body.transform(e) }), e(oe, function (n, e) { n.init && (n.init = n.init.transform(e)), n.condition && (n.condition = n.condition.transform(e)), n.step && (n.step = n.step.transform(e)), n.body = n.body.transform(e) }), e(ae, function (n, e) { n.init = n.init.transform(e), n.object = n.object.transform(e), n.body = n.body.transform(e) }), e(ue, function (n, e) { n.expression = n.expression.transform(e), n.body = n.body.transform(e) }), e(_e, function (n, e) { n.value && (n.value = n.value.transform(e)) }), e(ge, function (n, e) { n.label && (n.label = n.label.transform(e)) }), e(Ae, function (n, e) { n.condition = n.condition.transform(e), n.body = n.body.transform(e), n.alternative && (n.alternative = n.alternative.transform(e)) }), e(we, function (n, e) { n.expression = n.expression.transform(e), n.body = t(n.body, e) }), e(Fe, function (n, e) { n.expression = n.expression.transform(e), n.body = t(n.body, e) }), e(Ce, function (n, e) { n.body = t(n.body, e), n.bcatch && (n.bcatch = n.bcatch.transform(e)), n.bfinally && (n.bfinally = n.bfinally.transform(e)) }), e(Se, function (n, e) { n.argname = n.argname.transform(e), n.body = t(n.body, e) }), e(Be, function (n, e) { n.definitions = t(n.definitions, e) }), e($e, function (n, e) { n.name = n.name.transform(e), n.value && (n.value = n.value.transform(e)) }), e(fe, function (n, e) { n.name && (n.name = n.name.transform(e)), n.argnames = t(n.argnames, e), n.body = t(n.body, e) }), e(Oe, function (n, e) { n.expression = n.expression.transform(e), n.args = t(n.args, e) }), e(Me, function (n, e) { n.car = n.car.transform(e), n.cdr = n.cdr.transform(e) }), e(He, function (n, e) { n.expression = n.expression.transform(e) }), e(qe, function (n, e) { n.expression = n.expression.transform(e), n.property = n.property.transform(e) }), e(Pe, function (n, e) { n.expression = n.expression.transform(e) }), e(Ie, function (n, e) { n.left = n.left.transform(e), n.right = n.right.transform(e) }), e(Ue, function (n, e) { n.condition = n.condition.transform(e), n.consequent = n.consequent.transform(e), n.alternative = n.alternative.transform(e) }), e(Le, function (n, e) { n.elements = t(n.elements, e) }), e(We, function (n, e) { n.properties = t(n.properties, e) }), e(Ye, function (n, e) { n.value = n.value.transform(e) }) }(), j.prototype = { unmangleable: function (n) { return this.global && !(n && n.toplevel) || this.undeclared || !(n && n.eval) && (this.scope.uses_eval || this.scope.uses_with) }, mangle: function (n) { if (!this.mangled_name && !this.unmangleable(n)) { var e = this.scope; !n.screw_ie8 && this.orig[0] instanceof it && (e = e.parent_scope), this.mangled_name = e.next_mangled(n, this) } } }, ce.DEFMETHOD("figure_out_scope", function (n) { n = c(n, { screw_ie8: !1 }); var e = this, t = e.parent_scope = null, r = null, i = 0, o = new E(function (e, a) { if (n.screw_ie8 && e instanceof Se) { var u = t; return t = new se(e), t.init_scope_vars(i), t.parent_scope = u, a(), t = u, !0 } if (e instanceof se) { e.init_scope_vars(i); var u = e.parent_scope = t, s = r; return r = t = e, ++i, a(), --i, t = u, r = s, !0 } if (e instanceof X) return e.scope = t, p(t.directives, e.value), !0; if (e instanceof ue) for (var c = t; c; c = c.parent_scope) c.uses_with = !0; else if (e instanceof Je && (e.scope = t), e instanceof it) r.def_function(e); else if (e instanceof rt) (e.scope = r.parent_scope).def_function(e); else if (e instanceof nt || e instanceof et) { var f = r.def_variable(e); f.constant = e instanceof et, f.init = o.parent().value } else e instanceof ot && (n.screw_ie8 ? t : r).def_variable(e) }); e.walk(o); var a = null, u = e.globals = new y, o = new E(function (n, t) { if (n instanceof fe) { var r = a; return a = n, t(), a = r, !0 } if (n instanceof ut) { var i = n.name, s = n.scope.find_variable(i); if (s) n.thedef = s; else { var c; if (u.has(i) ? c = u.get(i) : (c = new j(e, u.size(), n), c.undeclared = !0, c.global = !0, u.set(i, c)), n.thedef = c, "eval" == i && o.parent() instanceof Oe) for (var f = n.scope; f && !f.uses_eval; f = f.parent_scope) f.uses_eval = !0; a && "arguments" == i && (a.uses_arguments = !0) } return n.reference(), !0 } }); e.walk(o) }), se.DEFMETHOD("init_scope_vars", function (n) { this.directives = [], this.variables = new y, this.functions = new y, this.uses_with = !1, this.uses_eval = !1, this.parent_scope = null, this.enclosed = [], this.cname = -1, this.nesting = n }), se.DEFMETHOD("strict", function () { return this.has_directive("use strict") }), fe.DEFMETHOD("init_scope_vars", function () { se.prototype.init_scope_vars.apply(this, arguments), this.uses_arguments = !1 }), ut.DEFMETHOD("reference", function () { var n = this.definition(); n.references.push(this); for (var e = this.scope; e && (p(e.enclosed, n), e !== n.scope) ;) e = e.parent_scope; this.frame = this.scope.nesting - n.scope.nesting }), se.DEFMETHOD("find_variable", function (n) { return n instanceof Je && (n = n.name), this.variables.get(n) || this.parent_scope && this.parent_scope.find_variable(n) }), se.DEFMETHOD("has_directive", function (n) { return this.parent_scope && this.parent_scope.has_directive(n) || (this.directives.indexOf(n) >= 0 ? this : null) }), se.DEFMETHOD("def_function", function (n) { this.functions.set(n.name, this.def_variable(n)) }), se.DEFMETHOD("def_variable", function (n) { var e; return this.variables.has(n.name) ? (e = this.variables.get(n.name), e.orig.push(n)) : (e = new j(this, this.variables.size(), n), this.variables.set(n.name, e), e.global = !this.parent_scope), n.thedef = e }), se.DEFMETHOD("next_mangled", function (n) { var e = this.enclosed; n: for (; ;) { var t = Vt(++this.cname); if (B(t) && !(n.except.indexOf(t) >= 0)) { for (var r = e.length; --r >= 0;) { var i = e[r], o = i.mangled_name || i.unmangleable(n) && i.name; if (t == o) continue n } return t } } }), pe.DEFMETHOD("next_mangled", function (n, e) { for (var t = e.orig[0] instanceof tt && this.name && this.name.definition() ; ;) { var r = fe.prototype.next_mangled.call(this, n, e); if (!t || t.mangled_name != r) return r } }), se.DEFMETHOD("references", function (n) { return n instanceof Je && (n = n.definition()), this.enclosed.indexOf(n) < 0 ? null : n }), Je.DEFMETHOD("unmangleable", function (n) { return this.definition().unmangleable(n) }), Qe.DEFMETHOD("unmangleable", function () { return !0 }), at.DEFMETHOD("unmangleable", function () { return !1 }), Je.DEFMETHOD("unreferenced", function () { return 0 == this.definition().references.length && !(this.scope.uses_eval || this.scope.uses_with) }), Je.DEFMETHOD("undeclared", function () { return this.definition().undeclared }), st.DEFMETHOD("undeclared", function () { return !1 }), at.DEFMETHOD("undeclared", function () { return !1 }), Je.DEFMETHOD("definition", function () { return this.thedef }), Je.DEFMETHOD("global", function () { return this.definition().global }), ce.DEFMETHOD("_default_mangler_options", function (n) { return c(n, { except: [], eval: !1, sort: !1, toplevel: !1, screw_ie8: !1 }) }), ce.DEFMETHOD("mangle_names", function (n) { n = this._default_mangler_options(n); var e = -1, t = [], r = new E(function (i, o) { if (i instanceof ne) { var a = e; return o(), e = a, !0 } if (i instanceof se) { var u = (r.parent(), []); return i.variables.each(function (e) { n.except.indexOf(e.name) < 0 && u.push(e) }), n.sort && u.sort(function (n, e) { return e.references.length - n.references.length }), void t.push.apply(t, u) } if (i instanceof at) { var s; do s = Vt(++e); while (!B(s)); return i.mangled_name = s, !0 } return n.screw_ie8 && i instanceof ot ? void t.push(i.definition()) : void 0 }); this.walk(r), t.forEach(function (e) { e.mangle(n) }) }), ce.DEFMETHOD("compute_char_frequency", function (n) { n = this._default_mangler_options(n); var e = new E(function (e) { e instanceof ft ? Vt.consider(e.print_to_string()) : e instanceof ve ? Vt.consider("return") : e instanceof me ? Vt.consider("throw") : e instanceof ye ? Vt.consider("continue") : e instanceof be ? Vt.consider("break") : e instanceof Y ? Vt.consider("debugger") : e instanceof X ? Vt.consider(e.value) : e instanceof ie ? Vt.consider("while") : e instanceof re ? Vt.consider("do while") : e instanceof Ae ? (Vt.consider("if"), e.alternative && Vt.consider("else")) : e instanceof xe ? Vt.consider("var") : e instanceof Te ? Vt.consider("const") : e instanceof fe ? Vt.consider("function") : e instanceof oe ? Vt.consider("for") : e instanceof ae ? Vt.consider("for in") : e instanceof we ? Vt.consider("switch") : e instanceof Fe ? Vt.consider("case") : e instanceof De ? Vt.consider("default") : e instanceof ue ? Vt.consider("with") : e instanceof Ge ? Vt.consider("set" + e.key) : e instanceof Ke ? Vt.consider("get" + e.key) : e instanceof Xe ? Vt.consider(e.key) : e instanceof Ne ? Vt.consider("new") : e instanceof ct ? Vt.consider("this") : e instanceof Ce ? Vt.consider("try") : e instanceof Se ? Vt.consider("catch") : e instanceof ke ? Vt.consider("finally") : e instanceof Je && e.unmangleable(n) ? Vt.consider(e.name) : e instanceof Pe || e instanceof Ie ? Vt.consider(e.operator) : e instanceof He && Vt.consider(e.property) }); this.walk(e), Vt.sort() }); var Vt = function () { function n() { r = {}, t = i.split("").map(function (n) { return n.charCodeAt(0) }), t.forEach(function (n) { r[n] = 0 }) } function e(n) { var e = "", r = 54; do e += String.fromCharCode(t[n % r]), n = Math.floor(n / r), r = 64; while (n > 0); return e } var t, r, i = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789"; return e.consider = function (n) { for (var e = n.length; --e >= 0;) { var t = n.charCodeAt(e); t in r && ++r[t] } }, e.sort = function () { t = _(t, function (n, e) { return F(n) && !F(e) ? 1 : F(e) && !F(n) ? -1 : r[e] - r[n] }) }, e.reset = n, n(), e.get = function () { return t }, e.freq = function () { return r }, e }(); ce.DEFMETHOD("scope_warnings", function (n) { n = c(n, { undeclared: !1, unreferenced: !0, assign_to_global: !0, func_arguments: !0, nested_defuns: !0, eval: !0 }); var e = new E(function (t) { if (n.undeclared && t instanceof ut && t.undeclared() && L.warn("Undeclared symbol: {name} [{file}:{line},{col}]", { name: t.name, file: t.start.file, line: t.start.line, col: t.start.col }), n.assign_to_global) { var r = null; t instanceof Ve && t.left instanceof ut ? r = t.left : t instanceof ae && t.init instanceof ut && (r = t.init), r && (r.undeclared() || r.global() && r.scope !== r.definition().scope) && L.warn("{msg}: {name} [{file}:{line},{col}]", { msg: r.undeclared() ? "Accidental global?" : "Assignment to global", name: r.name, file: r.start.file, line: r.start.line, col: r.start.col }) } n.eval && t instanceof ut && t.undeclared() && "eval" == t.name && L.warn("Eval is used [{file}:{line},{col}]", t.start), n.unreferenced && (t instanceof Ze || t instanceof at) && t.unreferenced() && L.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]", { type: t instanceof at ? "Label" : "Symbol", name: t.name, file: t.start.file, line: t.start.line, col: t.start.col }), n.func_arguments && t instanceof fe && t.uses_arguments && L.warn("arguments used in function {name} [{file}:{line},{col}]", { name: t.name ? t.name.name : "anonymous", file: t.start.file, line: t.start.line, col: t.start.col }), n.nested_defuns && t instanceof de && !(e.parent() instanceof se) && L.warn('Function {name} declared in nested statement "{type}" [{file}:{line},{col}]', { name: t.name.name, type: e.parent().TYPE, file: t.start.file, line: t.start.line, col: t.start.col }) }); this.walk(e) }), function () {
        function n(n, e) { n.DEFMETHOD("_codegen", e) } function e(n, e) { n.DEFMETHOD("needs_parens", e) } function t(n) { var e = n.parent(); return e instanceof Pe ? !0 : e instanceof Ie && !(e instanceof Ve) ? !0 : e instanceof Oe && e.expression === this ? !0 : e instanceof Ue && e.condition === this ? !0 : e instanceof Re && e.expression === this ? !0 : void 0 } function r(n, e, t) { var r = n.length - 1; n.forEach(function (n, i) { n instanceof Q || (t.indent(), n.print(t), i == r && e || (t.newline(), e && t.newline())) }) } function i(n, e) { n.length > 0 ? e.with_block(function () { r(n, !1, e) }) : e.print("{}") } function o(n, e) { if (e.option("bracketize")) return void h(n.body, e); if (!n.body) return e.force_semicolon(); if (n.body instanceof re && !e.option("screw_ie8")) return void h(n.body, e); for (var t = n.body; ;) if (t instanceof Ae) { if (!t.alternative) return void h(n.body, e); t = t.alternative } else { if (!(t instanceof Z)) break; t = t.body } s(n.body, e) } function a(n, e, t) { if (t) try { n.walk(new E(function (n) { if (n instanceof Ie && "in" == n.operator) throw e })), n.print(e) } catch (r) { if (r !== e) throw r; n.print(e, !0) } else n.print(e) } function u(n) { return [92, 47, 46, 43, 42, 63, 40, 41, 91, 93, 123, 125, 36, 94, 58, 124, 33, 10, 13, 0, 65279, 8232, 8233].indexOf(n) < 0 } function s(n, e) { e.option("bracketize") ? !n || n instanceof Q ? e.print("{}") : n instanceof J ? n.print(e) : e.with_block(function () { e.indent(), n.print(e), e.newline() }) : !n || n instanceof Q ? e.force_semicolon() : n.print(e) } function c(n) { for (var e = n.stack(), t = e.length, r = e[--t], i = e[--t]; t > 0;) { if (i instanceof W && i.body === r) return !0; if (!(i instanceof Me && i.car === r || i instanceof Oe && i.expression === r && !(i instanceof Ne) || i instanceof He && i.expression === r || i instanceof qe && i.expression === r || i instanceof Ue && i.condition === r || i instanceof Ie && i.left === r || i instanceof ze && i.expression === r)) return !1; r = i, i = e[--t] } } function f(n, e) { return 0 == n.args.length && !e.option("beautify") } function p(n) { for (var e = n[0], t = e.length, r = 1; r < n.length; ++r) n[r].length < t && (e = n[r], t = e.length); return e } function d(n) { var e, t = n.toString(10), r = [t.replace(/^0\./, ".").replace("e+", "e")]; return Math.floor(n) === n ? (n >= 0 ? r.push("0x" + n.toString(16).toLowerCase(), "0" + n.toString(8)) : r.push("-0x" + (-n).toString(16).toLowerCase(), "-0" + (-n).toString(8)), (e = /^(.*?)(0+)$/.exec(n)) && r.push(e[1] + "e" + e[2].length)) : (e = /^0?\.(0+)(.*)$/.exec(n)) && r.push(e[2] + "e-" + (e[1].length + e[2].length), t.substr(t.indexOf("."))), p(r) } function h(n, e) { return n instanceof J ? void n.print(e) : void e.with_block(function () { e.indent(), n.print(e), e.newline() }) } function _(n, e) { n.DEFMETHOD("add_source_map", function (n) { e(this, n) }) } function v(n, e) { e.add_mapping(n.start) } L.DEFMETHOD("print", function (n, e) { function t() { r.add_comments(n), r.add_source_map(n), i(r, n) } var r = this, i = r._codegen; n.push_node(r), e || r.needs_parens(n) ? n.with_parens(t) : t(), n.pop_node() }), L.DEFMETHOD("print_to_string", function (n) { var e = z(n); return this.print(e), e.get() }), L.DEFMETHOD("add_comments", function (n) { var e = n.option("comments"), t = this; if (e) { var r = t.start; if (r && !r._comments_dumped) { r._comments_dumped = !0; var i = r.comments_before || []; t instanceof _e && t.value && t.value.walk(new E(function (n) { return n.start && n.start.comments_before && (i = i.concat(n.start.comments_before), n.start.comments_before = []), n instanceof pe || n instanceof Le || n instanceof We ? !0 : void 0 })), e.test ? i = i.filter(function (n) { return e.test(n.value) }) : "function" == typeof e && (i = i.filter(function (n) { return e(t, n) })), i.forEach(function (e) { /comment[134]/.test(e.type) ? (n.print("//" + e.value + "\n"), n.indent()) : "comment2" == e.type && (n.print("/*" + e.value + "*/"), r.nlb ? (n.print("\n"), n.indent()) : n.space()) }) } } }), e(L, function () { return !1 }), e(pe, function (n) { return c(n) }), e(We, function (n) { return c(n) }), e(Pe, function (n) { var e = n.parent(); return e instanceof Re && e.expression === this }), e(Me, function (n) { var e = n.parent(); return e instanceof Oe || e instanceof Pe || e instanceof Ie || e instanceof $e || e instanceof Re || e instanceof Le || e instanceof Ye || e instanceof Ue }), e(Ie, function (n) {
            var e = n.parent(); if (e instanceof Oe && e.expression === this) return !0;
            if (e instanceof Pe) return !0; if (e instanceof Re && e.expression === this) return !0; if (e instanceof Ie) { var t = e.operator, r = zt[t], i = this.operator, o = zt[i]; if (r > o || r == o && this === e.right) return !0 }
        }), e(Re, function (n) { var e = n.parent(); if (e instanceof Ne && e.expression === this) try { this.walk(new E(function (n) { if (n instanceof Oe) throw e })) } catch (t) { if (t !== e) throw t; return !0 } }), e(Oe, function (n) { var e, t = n.parent(); return t instanceof Ne && t.expression === this ? !0 : this.expression instanceof pe && t instanceof Re && t.expression === this && (e = n.parent(1)) instanceof Ve && e.left === t }), e(Ne, function (n) { var e = n.parent(); return f(this, n) && (e instanceof Re || e instanceof Oe && e.expression === this) ? !0 : void 0 }), e(pt, function (n) { var e = n.parent(); return this.getValue() < 0 && e instanceof Re && e.expression === this ? !0 : void 0 }), e(vt, function (n) { var e = n.parent(); return e instanceof Re && e.expression === this ? !0 : void 0 }), e(Ve, t), e(Ue, t), n(X, function (n, e) { e.print_string(n.value), e.semicolon() }), n(Y, function (n, e) { e.print("debugger"), e.semicolon() }), Z.DEFMETHOD("_do_print_body", function (n) { s(this.body, n) }), n(W, function (n, e) { n.body.print(e), e.semicolon() }), n(ce, function (n, e) { r(n.body, !0, e), e.print("") }), n(ne, function (n, e) { n.label.print(e), e.colon(), n.body.print(e) }), n(G, function (n, e) { n.body.print(e), e.semicolon() }), n(J, function (n, e) { i(n.body, e) }), n(Q, function (n, e) { e.semicolon() }), n(re, function (n, e) { e.print("do"), e.space(), n._do_print_body(e), e.space(), e.print("while"), e.space(), e.with_parens(function () { n.condition.print(e) }), e.semicolon() }), n(ie, function (n, e) { e.print("while"), e.space(), e.with_parens(function () { n.condition.print(e) }), e.space(), n._do_print_body(e) }), n(oe, function (n, e) { e.print("for"), e.space(), e.with_parens(function () { n.init ? (n.init instanceof Be ? n.init.print(e) : a(n.init, e, !0), e.print(";"), e.space()) : e.print(";"), n.condition ? (n.condition.print(e), e.print(";"), e.space()) : e.print(";"), n.step && n.step.print(e) }), e.space(), n._do_print_body(e) }), n(ae, function (n, e) { e.print("for"), e.space(), e.with_parens(function () { n.init.print(e), e.space(), e.print("in"), e.space(), n.object.print(e) }), e.space(), n._do_print_body(e) }), n(ue, function (n, e) { e.print("with"), e.space(), e.with_parens(function () { n.expression.print(e) }), e.space(), n._do_print_body(e) }), fe.DEFMETHOD("_do_print", function (n, e) { var t = this; e || n.print("function"), t.name && (n.space(), t.name.print(n)), n.with_parens(function () { t.argnames.forEach(function (e, t) { t && n.comma(), e.print(n) }) }), n.space(), i(t.body, n) }), n(fe, function (n, e) { n._do_print(e) }), _e.DEFMETHOD("_do_print", function (n, e) { n.print(e), this.value && (n.space(), this.value.print(n)), n.semicolon() }), n(ve, function (n, e) { n._do_print(e, "return") }), n(me, function (n, e) { n._do_print(e, "throw") }), ge.DEFMETHOD("_do_print", function (n, e) { n.print(e), this.label && (n.space(), this.label.print(n)), n.semicolon() }), n(be, function (n, e) { n._do_print(e, "break") }), n(ye, function (n, e) { n._do_print(e, "continue") }), n(Ae, function (n, e) { e.print("if"), e.space(), e.with_parens(function () { n.condition.print(e) }), e.space(), n.alternative ? (o(n, e), e.space(), e.print("else"), e.space(), s(n.alternative, e)) : n._do_print_body(e) }), n(we, function (n, e) { e.print("switch"), e.space(), e.with_parens(function () { n.expression.print(e) }), e.space(), n.body.length > 0 ? e.with_block(function () { n.body.forEach(function (n, t) { t && e.newline(), e.indent(!0), n.print(e) }) }) : e.print("{}") }), Ee.DEFMETHOD("_do_print_body", function (n) { this.body.length > 0 && (n.newline(), this.body.forEach(function (e) { n.indent(), e.print(n), n.newline() })) }), n(De, function (n, e) { e.print("default:"), n._do_print_body(e) }), n(Fe, function (n, e) { e.print("case"), e.space(), n.expression.print(e), e.print(":"), n._do_print_body(e) }), n(Ce, function (n, e) { e.print("try"), e.space(), i(n.body, e), n.bcatch && (e.space(), n.bcatch.print(e)), n.bfinally && (e.space(), n.bfinally.print(e)) }), n(Se, function (n, e) { e.print("catch"), e.space(), e.with_parens(function () { n.argname.print(e) }), e.space(), i(n.body, e) }), n(ke, function (n, e) { e.print("finally"), e.space(), i(n.body, e) }), Be.DEFMETHOD("_do_print", function (n, e) { n.print(e), n.space(), this.definitions.forEach(function (e, t) { t && n.comma(), e.print(n) }); var t = n.parent(), r = t instanceof oe || t instanceof ae, i = r && t.init === this; i || n.semicolon() }), n(xe, function (n, e) { n._do_print(e, "var") }), n(Te, function (n, e) { n._do_print(e, "const") }), n($e, function (n, e) { if (n.name.print(e), n.value) { e.space(), e.print("="), e.space(); var t = e.parent(1), r = t instanceof oe || t instanceof ae; a(n.value, e, r) } }), n(Oe, function (n, e) { n.expression.print(e), n instanceof Ne && f(n, e) || e.with_parens(function () { n.args.forEach(function (n, t) { t && e.comma(), n.print(e) }) }) }), n(Ne, function (n, e) { e.print("new"), e.space(), Oe.prototype._codegen(n, e) }), Me.DEFMETHOD("_do_print", function (n) { this.car.print(n), this.cdr && (n.comma(), n.should_break() && (n.newline(), n.indent()), this.cdr.print(n)) }), n(Me, function (n, e) { n._do_print(e) }), n(He, function (n, e) { var t = n.expression; t.print(e), t instanceof pt && t.getValue() >= 0 && (/[xa-f.]/i.test(e.last()) || e.print(".")), e.print("."), e.add_mapping(n.end), e.print_name(n.property) }), n(qe, function (n, e) { n.expression.print(e), e.print("["), n.property.print(e), e.print("]") }), n(je, function (n, e) { var t = n.operator; e.print(t), (/^[a-z]/i.test(t) || /[+-]$/.test(t) && n.expression instanceof je && /^[+-]/.test(n.expression.operator)) && e.space(), n.expression.print(e) }), n(ze, function (n, e) { n.expression.print(e), e.print(n.operator) }), n(Ie, function (n, e) { n.left.print(e), e.space(), e.print(n.operator), "<" == n.operator && n.right instanceof je && "!" == n.right.operator && n.right.expression instanceof je && "--" == n.right.expression.operator ? e.print(" ") : e.space(), n.right.print(e) }), n(Ue, function (n, e) { n.condition.print(e), e.space(), e.print("?"), e.space(), n.consequent.print(e), e.space(), e.colon(), n.alternative.print(e) }), n(Le, function (n, e) { e.with_square(function () { var t = n.elements, r = t.length; r > 0 && e.space(), t.forEach(function (n, t) { t && e.comma(), n.print(e), t === r - 1 && n instanceof gt && e.comma() }), r > 0 && e.space() }) }), n(We, function (n, e) { n.properties.length > 0 ? e.with_block(function () { n.properties.forEach(function (n, t) { t && (e.print(","), e.newline()), e.indent(), n.print(e) }), e.newline() }) : e.print("{}") }), n(Xe, function (n, e) { var t = n.key; e.option("quote_keys") ? e.print_string(t + "") : ("number" == typeof t || !e.option("beautify") && +t + "" == t) && parseFloat(t) >= 0 ? e.print(d(t)) : (Ft(t) ? e.option("screw_ie8") : $(t)) ? e.print_name(t) : e.print_string(t), e.colon(), n.value.print(e) }), n(Ge, function (n, e) { e.print("set"), e.space(), n.key.print(e), n.value._do_print(e, !0) }), n(Ke, function (n, e) { e.print("get"), e.space(), n.key.print(e), n.value._do_print(e, !0) }), n(Je, function (n, e) { var t = n.definition(); e.print_name(t ? t.mangled_name || t.name : n.name) }), n(mt, function (n, e) { e.print("void 0") }), n(gt, l), n(bt, function (n, e) { e.print("1/0") }), n(vt, function (n, e) { e.print("0/0") }), n(ct, function (n, e) { e.print("this") }), n(ft, function (n, e) { e.print(n.getValue()) }), n(lt, function (n, e) { e.print_string(n.getValue()) }), n(pt, function (n, e) { e.print(d(n.getValue())) }), n(dt, function (n, e) { var t = n.getValue().toString(); e.option("ascii_only") ? t = e.to_ascii(t) : e.option("unescape_regexps") && (t = t.split("\\\\").map(function (n) { return n.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g, function (n) { var e = parseInt(n.substr(2), 16); return u(e) ? String.fromCharCode(e) : n }) }).join("\\\\")), e.print(t); var r = e.parent(); r instanceof Ie && /^in/.test(r.operator) && r.left === n && e.print(" ") }), _(L, l), _(X, v), _(Y, v), _(Je, v), _(he, v), _(Z, v), _(ne, l), _(fe, v), _(we, v), _(Ee, v), _(J, v), _(ce, l), _(Ne, v), _(Ce, v), _(Se, v), _(ke, v), _(Be, v), _(ft, v), _(Ye, function (n, e) { e.add_mapping(n.start, n.key) })
    }(), I.prototype = new P, f(I.prototype, { option: function (n) { return this.options[n] }, warn: function () { this.options.warnings && L.warn.apply(L, arguments) }, before: function (n, e) { if (n._squeezed) return n; var t = !1; return n instanceof se && (n = n.hoist_declarations(this), t = !0), e(n, this), n = n.optimize(this), t && n instanceof se && (n.drop_unused(this), e(n, this)), n._squeezed = !0, n } }), function () {
        function n(n, e) { n.DEFMETHOD("optimize", function (n) { var t = this; if (t._optimized) return t; var r = e(t, n); return r._optimized = !0, r === t ? r : r.transform(n) }) } function e(n, e, t) { return t || (t = {}), e && (t.start || (t.start = e.start), t.end || (t.end = e.end)), new n(t) } function t(n, t, r) { if (t instanceof L) return t.transform(n); switch (typeof t) { case "string": return e(lt, r, { value: t }).optimize(n); case "number": return e(isNaN(t) ? vt : pt, r, { value: t }).optimize(n); case "boolean": return e(t ? wt : At, r).optimize(n); case "undefined": return e(mt, r).optimize(n); default: if (null === t) return e(_t, r).optimize(n); if (t instanceof RegExp) return e(dt, r).optimize(n); throw new Error(d("Can't handle constant of type: {type}", { type: typeof t })) } } function r(n) { if (null === n) return []; if (n instanceof J) return n.body; if (n instanceof Q) return []; if (n instanceof W) return [n]; throw new Error("Can't convert thing to statement array") } function i(n) { return null === n ? !0 : n instanceof Q ? !0 : n instanceof J ? 0 == n.body.length : !1 } function u(n) { return n instanceof we ? n : (n instanceof oe || n instanceof ae || n instanceof te) && n.body instanceof J ? n.body : n } function s(n, t) { function i(n) { function r(n, t) { return e(G, n, { body: e(Ve, n, { operator: "=", left: e(He, t, { expression: e(ut, t, t), property: "$inject" }), right: e(Le, n, { elements: n.argnames.map(function (n) { return e(lt, n, { value: n.name }) }) }) }) }) } return n.reduce(function (n, e) { n.push(e); var i = e.start, o = i.comments_before; if (o && o.length > 0) { var a = o.pop(); /@ngInject/.test(a.value) && (e instanceof de ? n.push(r(e, e.name)) : e instanceof Be ? e.definitions.forEach(function (e) { e.value && e.value instanceof fe && n.push(r(e.value, e.name)) }) : t.warn("Unknown statement marked with @ngInject [{file}:{line},{col}]", i)) } return n }, []) } function o(n) { var e = []; return n.reduce(function (n, t) { return t instanceof J ? (_ = !0, n.push.apply(n, o(t.body))) : t instanceof Q ? _ = !0 : t instanceof X ? e.indexOf(t.value) < 0 ? (n.push(t), e.push(t.value)) : _ = !0 : n.push(t), n }, []) } function a(n, t) { var i = t.self(), o = i instanceof fe, a = []; n: for (var s = n.length; --s >= 0;) { var c = n[s]; switch (!0) { case o && c instanceof ve && !c.value && 0 == a.length: _ = !0; continue n; case c instanceof Ae: if (c.body instanceof ve) { if ((o && 0 == a.length || a[0] instanceof ve && !a[0].value) && !c.body.value && !c.alternative) { _ = !0; var f = e(G, c.condition, { body: c.condition }); a.unshift(f); continue n } if (a[0] instanceof ve && c.body.value && a[0].value && !c.alternative) { _ = !0, c = c.clone(), c.alternative = a[0], a[0] = c.transform(t); continue n } if ((0 == a.length || a[0] instanceof ve) && c.body.value && !c.alternative && o) { _ = !0, c = c.clone(), c.alternative = a[0] || e(ve, c, { value: e(mt, c) }), a[0] = c.transform(t); continue n } if (!c.body.value && o) { _ = !0, c = c.clone(), c.condition = c.condition.negate(t), c.body = e(J, c, { body: r(c.alternative).concat(a) }), c.alternative = null, a = [c.transform(t)]; continue n } if (1 == a.length && o && a[0] instanceof G && (!c.alternative || c.alternative instanceof G)) { _ = !0, a.push(e(ve, a[0], { value: e(mt, a[0]) }).transform(t)), a = r(c.alternative).concat(a), a.unshift(c); continue n } } var l = v(c.body), p = l instanceof ge ? t.loopcontrol_target(l.label) : null; if (l && (l instanceof ve && !l.value && o || l instanceof ye && i === u(p) || l instanceof be && p instanceof J && i === p)) { l.label && h(l.label.thedef.references, l), _ = !0; var d = r(c.body).slice(0, -1); c = c.clone(), c.condition = c.condition.negate(t), c.body = e(J, c, { body: r(c.alternative).concat(a) }), c.alternative = e(J, c, { body: d }), a = [c.transform(t)]; continue n } var l = v(c.alternative), p = l instanceof ge ? t.loopcontrol_target(l.label) : null; if (l && (l instanceof ve && !l.value && o || l instanceof ye && i === u(p) || l instanceof be && p instanceof J && i === p)) { l.label && h(l.label.thedef.references, l), _ = !0, c = c.clone(), c.body = e(J, c.body, { body: r(c.body).concat(a) }), c.alternative = e(J, c.alternative, { body: r(c.alternative).slice(0, -1) }), a = [c.transform(t)]; continue n } a.unshift(c); break; default: a.unshift(c) } } return a } function s(n, e) { var t = !1, r = n.length, i = e.self(); return n = n.reduce(function (n, r) { if (t) c(e, r, n); else { if (r instanceof ge) { var o = e.loopcontrol_target(r.label); r instanceof be && o instanceof J && u(o) === i || r instanceof ye && u(o) === i ? r.label && h(r.label.thedef.references, r) : n.push(r) } else n.push(r); v(r) && (t = !0) } return n }, []), _ = n.length != r, n } function f(n, t) { function r() { i = Me.from_array(i), i && o.push(e(G, i, { body: i })), i = [] } if (n.length < 2) return n; var i = [], o = []; return n.forEach(function (n) { n instanceof G ? i.push(n.body) : (r(), o.push(n)) }), r(), o = l(o, t), _ = o.length != n.length, o } function l(n, t) { function r(n) { i.pop(); var e = o.body; return e instanceof Me ? e.add(n) : e = Me.cons(e, n), e.transform(t) } var i = [], o = null; return n.forEach(function (n) { if (o) if (n instanceof oe) { var t = {}; try { o.body.walk(new E(function (n) { if (n instanceof Ie && "in" == n.operator) throw t })), !n.init || n.init instanceof Be ? n.init || (n.init = o.body, i.pop()) : n.init = r(n.init) } catch (a) { if (a !== t) throw a } } else n instanceof Ae ? n.condition = r(n.condition) : n instanceof ue ? n.expression = r(n.expression) : n instanceof _e && n.value ? n.value = r(n.value) : n instanceof _e ? n.value = r(e(mt, n)) : n instanceof we && (n.expression = r(n.expression)); i.push(n), o = n instanceof G ? n : null }), i } function p(n) { var e = null; return n.reduce(function (n, t) { return t instanceof Be && e && e.TYPE == t.TYPE ? (e.definitions = e.definitions.concat(t.definitions), _ = !0) : t instanceof oe && e instanceof Be && (!t.init || t.init.TYPE == e.TYPE) ? (_ = !0, n.pop(), t.init ? t.init.definitions = e.definitions.concat(t.init.definitions) : t.init = e, n.push(t), e = t) : (e = t, n.push(t)), n }, []) } function d(n) { n.forEach(function (n) { n instanceof G && (n.body = function t(n) { return n.transform(new P(function (n) { if (n instanceof Oe && n.expression instanceof pe) return e(je, n, { operator: "!", expression: n }); if (n instanceof Oe) n.expression = t(n.expression); else if (n instanceof Me) n.car = t(n.car); else if (n instanceof Ue) { var r = t(n.condition); if (r !== n.condition) { n.condition = r; var i = n.consequent; n.consequent = n.alternative, n.alternative = i } } return n })) }(n.body)) }) } var _; do _ = !1, t.option("angular") && (n = i(n)), n = o(n), t.option("dead_code") && (n = s(n, t)), t.option("if_return") && (n = a(n, t)), t.option("sequences") && (n = f(n, t)), t.option("join_vars") && (n = p(n, t)); while (_); return t.option("negate_iife") && d(n, t), n } function c(n, e, t) { n.warn("Dropping unreachable code [{file}:{line},{col}]", e.start), e.walk(new E(function (e) { return e instanceof Be ? (n.warn("Declarations in unreachable code! [{file}:{line},{col}]", e.start), e.remove_initializers(), t.push(e), !0) : e instanceof de ? (t.push(e), !0) : e instanceof se ? !0 : void 0 })) } function f(n, e) { return n.print_to_string().length > e.print_to_string().length ? e : n } function v(n) { return n && n.aborts() } function m(n, t) { function i(i) { i = r(i), n.body instanceof J ? (n.body = n.body.clone(), n.body.body = i.concat(n.body.body.slice(1)), n.body = n.body.transform(t)) : n.body = e(J, n.body, { body: i }).transform(t), m(n, t) } var o = n.body instanceof J ? n.body.body[0] : n.body; o instanceof Ae && (o.body instanceof be && t.loopcontrol_target(o.body.label) === n ? (n.condition = n.condition ? e(Ie, n.condition, { left: n.condition, operator: "&&", right: o.condition.negate(t) }) : o.condition.negate(t), i(o.alternative)) : o.alternative instanceof be && t.loopcontrol_target(o.alternative.label) === n && (n.condition = n.condition ? e(Ie, n.condition, { left: n.condition, operator: "&&", right: o.condition }) : o.condition, i(o.body))) } function A(n, e) { var t = e.option("pure_getters"); e.options.pure_getters = !1; var r = n.has_side_effects(e); return e.options.pure_getters = t, r } function w(n, t) { return t.option("booleans") && t.in_boolean_context() ? e(wt, n) : n } n(L, function (n) { return n }), L.DEFMETHOD("equivalent_to", function (n) { return this.print_to_string() == n.print_to_string() }), function (n) { var e = ["!", "delete"], t = ["in", "instanceof", "==", "!=", "===", "!==", "<", "<=", ">=", ">"]; n(L, function () { return !1 }), n(je, function () { return o(this.operator, e) }), n(Ie, function () { return o(this.operator, t) || ("&&" == this.operator || "||" == this.operator) && this.left.is_boolean() && this.right.is_boolean() }), n(Ue, function () { return this.consequent.is_boolean() && this.alternative.is_boolean() }), n(Ve, function () { return "=" == this.operator && this.right.is_boolean() }), n(Me, function () { return this.cdr.is_boolean() }), n(wt, function () { return !0 }), n(At, function () { return !0 }) }(function (n, e) { n.DEFMETHOD("is_boolean", e) }), function (n) { n(L, function () { return !1 }), n(lt, function () { return !0 }), n(je, function () { return "typeof" == this.operator }), n(Ie, function (n) { return "+" == this.operator && (this.left.is_string(n) || this.right.is_string(n)) }), n(Ve, function (n) { return ("=" == this.operator || "+=" == this.operator) && this.right.is_string(n) }), n(Me, function (n) { return this.cdr.is_string(n) }), n(Ue, function (n) { return this.consequent.is_string(n) && this.alternative.is_string(n) }), n(Oe, function (n) { return n.option("unsafe") && this.expression instanceof ut && "String" == this.expression.name && this.expression.undeclared() }) }(function (n, e) { n.DEFMETHOD("is_string", e) }), function (n) { function e(n, e) { if (!e) throw new Error("Compressor must be passed"); return n._eval(e) } L.DEFMETHOD("evaluate", function (e) { if (!e.option("evaluate")) return [this]; try { var r = this._eval(e); return [f(t(e, r, this), this), r] } catch (i) { if (i !== n) throw i; return [this] } }), n(W, function () { throw new Error(d("Cannot evaluate a statement [{file}:{line},{col}]", this.start)) }), n(pe, function () { throw n }), n(L, function () { throw n }), n(ft, function () { return this.getValue() }), n(je, function (t) { var r = this.expression; switch (this.operator) { case "!": return !e(r, t); case "typeof": if (r instanceof pe) return "function"; if (r = e(r, t), r instanceof RegExp) throw n; return typeof r; case "void": return void e(r, t); case "~": return ~e(r, t); case "-": if (r = e(r, t), 0 === r) throw n; return -r; case "+": return +e(r, t) } throw n }), n(Ie, function (t) { var r = this.left, i = this.right; switch (this.operator) { case "&&": return e(r, t) && e(i, t); case "||": return e(r, t) || e(i, t); case "|": return e(r, t) | e(i, t); case "&": return e(r, t) & e(i, t); case "^": return e(r, t) ^ e(i, t); case "+": return e(r, t) + e(i, t); case "*": return e(r, t) * e(i, t); case "/": return e(r, t) / e(i, t); case "%": return e(r, t) % e(i, t); case "-": return e(r, t) - e(i, t); case "<<": return e(r, t) << e(i, t); case ">>": return e(r, t) >> e(i, t); case ">>>": return e(r, t) >>> e(i, t); case "==": return e(r, t) == e(i, t); case "===": return e(r, t) === e(i, t); case "!=": return e(r, t) != e(i, t); case "!==": return e(r, t) !== e(i, t); case "<": return e(r, t) < e(i, t); case "<=": return e(r, t) <= e(i, t); case ">": return e(r, t) > e(i, t); case ">=": return e(r, t) >= e(i, t); case "in": return e(r, t) in e(i, t); case "instanceof": return e(r, t) instanceof e(i, t) } throw n }), n(Ue, function (n) { return e(this.condition, n) ? e(this.consequent, n) : e(this.alternative, n) }), n(ut, function (t) { var r = this.definition(); if (r && r.constant && r.init) return e(r.init, t); throw n }) }(function (n, e) { n.DEFMETHOD("_eval", e) }), function (n) { function t(n) { return e(je, n, { operator: "!", expression: n }) } n(L, function () { return t(this) }), n(W, function () { throw new Error("Cannot negate a statement") }), n(pe, function () { return t(this) }), n(je, function () { return "!" == this.operator ? this.expression : t(this) }), n(Me, function (n) { var e = this.clone(); return e.cdr = e.cdr.negate(n), e }), n(Ue, function (n) { var e = this.clone(); return e.consequent = e.consequent.negate(n), e.alternative = e.alternative.negate(n), f(t(this), e) }), n(Ie, function (n) { var e = this.clone(), r = this.operator; if (n.option("unsafe_comps")) switch (r) { case "<=": return e.operator = ">", e; case "<": return e.operator = ">=", e; case ">=": return e.operator = "<", e; case ">": return e.operator = "<=", e } switch (r) { case "==": return e.operator = "!=", e; case "!=": return e.operator = "==", e; case "===": return e.operator = "!==", e; case "!==": return e.operator = "===", e; case "&&": return e.operator = "||", e.left = e.left.negate(n), e.right = e.right.negate(n), f(t(this), e); case "||": return e.operator = "&&", e.left = e.left.negate(n), e.right = e.right.negate(n), f(t(this), e) } return t(this) }) }(function (n, e) { n.DEFMETHOD("negate", function (n) { return e.call(this, n) }) }), function (n) { n(L, function () { return !0 }), n(Q, function () { return !1 }), n(ft, function () { return !1 }), n(ct, function () { return !1 }), n(Oe, function (n) { var e = n.option("pure_funcs"); return e ? e.indexOf(this.expression.print_to_string()) < 0 : !0 }), n(K, function (n) { for (var e = this.body.length; --e >= 0;) if (this.body[e].has_side_effects(n)) return !0; return !1 }), n(G, function (n) { return this.body.has_side_effects(n) }), n(de, function () { return !0 }), n(pe, function () { return !1 }), n(Ie, function (n) { return this.left.has_side_effects(n) || this.right.has_side_effects(n) }), n(Ve, function () { return !0 }), n(Ue, function (n) { return this.condition.has_side_effects(n) || this.consequent.has_side_effects(n) || this.alternative.has_side_effects(n) }), n(Pe, function (n) { return "delete" == this.operator || "++" == this.operator || "--" == this.operator || this.expression.has_side_effects(n) }), n(ut, function () { return !1 }), n(We, function (n) { for (var e = this.properties.length; --e >= 0;) if (this.properties[e].has_side_effects(n)) return !0; return !1 }), n(Ye, function (n) { return this.value.has_side_effects(n) }), n(Le, function (n) { for (var e = this.elements.length; --e >= 0;) if (this.elements[e].has_side_effects(n)) return !0; return !1 }), n(He, function (n) { return n.option("pure_getters") ? this.expression.has_side_effects(n) : !0 }), n(qe, function (n) { return n.option("pure_getters") ? this.expression.has_side_effects(n) || this.property.has_side_effects(n) : !0 }), n(Re, function (n) { return !n.option("pure_getters") }), n(Me, function (n) { return this.car.has_side_effects(n) || this.cdr.has_side_effects(n) }) }(function (n, e) { n.DEFMETHOD("has_side_effects", e) }), function (n) { function e() { var n = this.body.length; return n > 0 && v(this.body[n - 1]) } n(W, function () { return null }), n(he, function () { return this }), n(J, e), n(Ee, e), n(Ae, function () { return this.alternative && v(this.body) && v(this.alternative) }) }(function (n, e) { n.DEFMETHOD("aborts", e) }), n(X, function (n) { return n.scope.has_directive(n.value) !== n.scope ? e(Q, n) : n }), n(Y, function (n, t) { return t.option("drop_debugger") ? e(Q, n) : n }), n(ne, function (n, t) { return n.body instanceof be && t.loopcontrol_target(n.body.label) === n.body ? e(Q, n) : 0 == n.label.references.length ? n.body : n }), n(K, function (n, e) { return n.body = s(n.body, e), n }), n(J, function (n, t) { switch (n.body = s(n.body, t), n.body.length) { case 1: return n.body[0]; case 0: return e(Q, n) } return n }), se.DEFMETHOD("drop_unused", function (n) { var t = this; if (n.option("unused") && !(t instanceof ce) && !t.uses_eval) { var r = [], i = new y, a = this, u = new E(function (e, o) { if (e !== t) { if (e instanceof de) return i.add(e.name.name, e), !0; if (e instanceof Be && a === t) return e.definitions.forEach(function (e) { e.value && (i.add(e.name.name, e.value), e.value.has_side_effects(n) && e.value.walk(u)) }), !0; if (e instanceof ut) return p(r, e.definition()), !0; if (e instanceof se) { var s = a; return a = e, o(), a = s, !0 } } }); t.walk(u); for (var s = 0; s < r.length; ++s) r[s].orig.forEach(function (n) { var e = i.get(n.name); e && e.forEach(function (n) { var e = new E(function (n) { n instanceof ut && p(r, n.definition()) }); n.walk(e) }) }); var c = new P(function (i, a, u) { if (i instanceof fe && !(i instanceof le) && !n.option("keep_fargs")) for (var s = i.argnames, f = s.length; --f >= 0;) { var l = s[f]; if (!l.unreferenced()) break; s.pop(), n.warn("Dropping unused function argument {name} [{file}:{line},{col}]", { name: l.name, file: l.start.file, line: l.start.line, col: l.start.col }) } if (i instanceof de && i !== t) return o(i.name.definition(), r) ? i : (n.warn("Dropping unused function {name} [{file}:{line},{col}]", { name: i.name.name, file: i.name.start.file, line: i.name.start.line, col: i.name.start.col }), e(Q, i)); if (i instanceof Be && !(c.parent() instanceof ae)) { var p = i.definitions.filter(function (e) { if (o(e.name.definition(), r)) return !0; var t = { name: e.name.name, file: e.name.start.file, line: e.name.start.line, col: e.name.start.col }; return e.value && e.value.has_side_effects(n) ? (e._unused_side_effects = !0, n.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", t), !0) : (n.warn("Dropping unused variable {name} [{file}:{line},{col}]", t), !1) }); p = _(p, function (n, e) { return !n.value && e.value ? -1 : !e.value && n.value ? 1 : 0 }); for (var d = [], f = 0; f < p.length;) { var h = p[f]; h._unused_side_effects ? (d.push(h.value), p.splice(f, 1)) : (d.length > 0 && (d.push(h.value), h.value = Me.from_array(d), d = []), ++f) } return d = d.length > 0 ? e(J, i, { body: [e(G, i, { body: Me.from_array(d) })] }) : null, 0 != p.length || d ? 0 == p.length ? d : (i.definitions = p, d && (d.body.unshift(i), i = d), i) : e(Q, i) } if (i instanceof oe && (a(i, this), i.init instanceof J)) { var v = i.init.body.slice(0, -1); return i.init = i.init.body.slice(-1)[0].body, v.push(i), u ? U.splice(v) : e(J, i, { body: v }) } return i instanceof se && i !== t ? i : void 0 }); t.transform(c) } }), se.DEFMETHOD("hoist_declarations", function (n) { var t = n.option("hoist_funs"), r = n.option("hoist_vars"), i = this; if (t || r) { var o = [], u = [], s = new y, c = 0, f = 0; i.walk(new E(function (n) { return n instanceof se && n !== i ? !0 : n instanceof xe ? (++f, !0) : void 0 })), r = r && f > 1; var l = new P(function (n) { if (n !== i) { if (n instanceof X) return o.push(n), e(Q, n); if (n instanceof de && t) return u.push(n), e(Q, n); if (n instanceof xe && r) { n.definitions.forEach(function (n) { s.set(n.name.name, n), ++c }); var a = n.to_assignments(), f = l.parent(); return f instanceof ae && f.init === n ? null == a ? n.definitions[0].name : a : f instanceof oe && f.init === n ? a : a ? e(G, n, { body: a }) : e(Q, n) } if (n instanceof se) return n } }); if (i = i.transform(l), c > 0) { var p = []; if (s.each(function (n, e) { i instanceof fe && a(function (e) { return e.name == n.name.name }, i.argnames) ? s.del(e) : (n = n.clone(), n.value = null, p.push(n), s.set(e, n)) }), p.length > 0) { for (var d = 0; d < i.body.length;) { if (i.body[d] instanceof G) { var _, v, m = i.body[d].body; if (m instanceof Ve && "=" == m.operator && (_ = m.left) instanceof Je && s.has(_.name)) { var g = s.get(_.name); if (g.value) break; g.value = m.right, h(p, g), p.push(g), i.body.splice(d, 1); continue } if (m instanceof Me && (v = m.car) instanceof Ve && "=" == v.operator && (_ = v.left) instanceof Je && s.has(_.name)) { var g = s.get(_.name); if (g.value) break; g.value = v.right, h(p, g), p.push(g), i.body[d].body = m.cdr; continue } } if (i.body[d] instanceof Q) i.body.splice(d, 1); else { if (!(i.body[d] instanceof J)) break; var b = [d, 1].concat(i.body[d].body); i.body.splice.apply(i.body, b) } } p = e(xe, i, { definitions: p }), u.push(p) } } i.body = o.concat(u, i.body) } return i }), n(G, function (n, t) { return t.option("side_effects") && !n.body.has_side_effects(t) ? (t.warn("Dropping side-effect-free statement [{file}:{line},{col}]", n.start), e(Q, n)) : n }), n(te, function (n, t) { var r = n.condition.evaluate(t); if (n.condition = r[0], !t.option("loops")) return n; if (r.length > 1) { if (r[1]) return e(oe, n, { body: n.body }); if (n instanceof ie && t.option("dead_code")) { var i = []; return c(t, n.body, i), e(J, n, { body: i }) } } return n }), n(ie, function (n, t) { return t.option("loops") ? (n = te.prototype.optimize.call(n, t), n instanceof ie && (m(n, t), n = e(oe, n, n).transform(t)), n) : n }), n(oe, function (n, t) { var r = n.condition; if (r && (r = r.evaluate(t), n.condition = r[0]), !t.option("loops")) return n; if (r && r.length > 1 && !r[1] && t.option("dead_code")) { var i = []; return n.init instanceof W ? i.push(n.init) : n.init && i.push(e(G, n.init, { body: n.init })), c(t, n.body, i), e(J, n, { body: i }) } return m(n, t), n }), n(Ae, function (n, t) { if (!t.option("conditionals")) return n; var r = n.condition.evaluate(t); if (n.condition = r[0], r.length > 1) if (r[1]) { if (t.warn("Condition always true [{file}:{line},{col}]", n.condition.start), t.option("dead_code")) { var o = []; return n.alternative && c(t, n.alternative, o), o.push(n.body), e(J, n, { body: o }).transform(t) } } else if (t.warn("Condition always false [{file}:{line},{col}]", n.condition.start), t.option("dead_code")) { var o = []; return c(t, n.body, o), n.alternative && o.push(n.alternative), e(J, n, { body: o }).transform(t) } i(n.alternative) && (n.alternative = null); var a = n.condition.negate(t), u = f(n.condition, a) === a; if (n.alternative && u) { u = !1, n.condition = a; var s = n.body; n.body = n.alternative || e(Q), n.alternative = s } if (i(n.body) && i(n.alternative)) return e(G, n.condition, { body: n.condition }).transform(t); if (n.body instanceof G && n.alternative instanceof G) return e(G, n, { body: e(Ue, n, { condition: n.condition, consequent: n.body.body, alternative: n.alternative.body }) }).transform(t); if (i(n.alternative) && n.body instanceof G) return u ? e(G, n, { body: e(Ie, n, { operator: "||", left: a, right: n.body.body }) }).transform(t) : e(G, n, { body: e(Ie, n, { operator: "&&", left: n.condition, right: n.body.body }) }).transform(t); if (n.body instanceof Q && n.alternative && n.alternative instanceof G) return e(G, n, { body: e(Ie, n, { operator: "||", left: n.condition, right: n.alternative.body }) }).transform(t); if (n.body instanceof _e && n.alternative instanceof _e && n.body.TYPE == n.alternative.TYPE) return e(n.body.CTOR, n, { value: e(Ue, n, { condition: n.condition, consequent: n.body.value || e(mt, n.body).optimize(t), alternative: n.alternative.value || e(mt, n.alternative).optimize(t) }) }).transform(t); if (n.body instanceof Ae && !n.body.alternative && !n.alternative && (n.condition = e(Ie, n.condition, { operator: "&&", left: n.condition, right: n.body.condition }).transform(t), n.body = n.body.body), v(n.body) && n.alternative) { var l = n.alternative; return n.alternative = null, e(J, n, { body: [n, l] }).transform(t) } if (v(n.alternative)) { var p = n.body; return n.body = n.alternative, n.condition = u ? a : n.condition.negate(t), n.alternative = null, e(J, n, { body: [n, p] }).transform(t) } return n }), n(we, function (n, t) { if (0 == n.body.length && t.option("conditionals")) return e(G, n, { body: n.expression }).transform(t); for (; ;) { var r = n.body[n.body.length - 1]; if (r) { var i = r.body[r.body.length - 1]; if (i instanceof be && u(t.loopcontrol_target(i.label)) === n && r.body.pop(), r instanceof De && 0 == r.body.length) { n.body.pop(); continue } } break } var o = n.expression.evaluate(t); n: if (2 == o.length) try { if (n.expression = o[0], !t.option("dead_code")) break n; var a = o[1], s = !1, c = !1, f = !1, l = !1, p = !1, d = new P(function (r, i, o) { if (r instanceof fe || r instanceof G) return r; if (r instanceof we && r === n) return r = r.clone(), i(r, this), p ? r : e(J, r, { body: r.body.reduce(function (n, e) { return n.concat(e.body) }, []) }).transform(t); if (r instanceof Ae || r instanceof Ce) { var u = s; return s = !c, i(r, this), s = u, r } if (r instanceof Z || r instanceof we) { var u = c; return c = !0, i(r, this), c = u, r } if (r instanceof be && this.loopcontrol_target(r.label) === n) return s ? (p = !0, r) : c ? r : (l = !0, o ? U.skip : e(Q, r)); if (r instanceof Ee && this.parent() === n) { if (l) return U.skip; if (r instanceof Fe) { var d = r.expression.evaluate(t); if (d.length < 2) throw n; return d[1] === a || f ? (f = !0, v(r) && (l = !0), i(r, this), r) : U.skip } return i(r, this), r } }); d.stack = t.stack.slice(), n = n.transform(d) } catch (h) { if (h !== n) throw h } return n }), n(Fe, function (n, e) { return n.body = s(n.body, e), n }), n(Ce, function (n, e) { return n.body = s(n.body, e), n }), Be.DEFMETHOD("remove_initializers", function () { this.definitions.forEach(function (n) { n.value = null }) }), Be.DEFMETHOD("to_assignments", function () { var n = this.definitions.reduce(function (n, t) { if (t.value) { var r = e(ut, t.name, t.name); n.push(e(Ve, t, { operator: "=", left: r, right: t.value })) } return n }, []); return 0 == n.length ? null : Me.from_array(n) }), n(Be, function (n) { return 0 == n.definitions.length ? e(Q, n) : n }), n(pe, function (n, e) { return n = fe.prototype.optimize.call(n, e), e.option("unused") && n.name && n.name.unreferenced() && (n.name = null), n }), n(Oe, function (n, r) {
            if (r.option("unsafe")) {
                var i = n.expression; if (i instanceof ut && i.undeclared()) switch (i.name) { case "Array": if (1 != n.args.length) return e(Le, n, { elements: n.args }).transform(r); break; case "Object": if (0 == n.args.length) return e(We, n, { properties: [] }); break; case "String": if (0 == n.args.length) return e(lt, n, { value: "" }); if (n.args.length <= 1) return e(Ie, n, { left: n.args[0], operator: "+", right: e(lt, n, { value: "" }) }).transform(r); break; case "Number": if (0 == n.args.length) return e(pt, n, { value: 0 }); if (1 == n.args.length) return e(je, n, { expression: n.args[0], operator: "+" }).transform(r); case "Boolean": if (0 == n.args.length) return e(At, n); if (1 == n.args.length) return e(je, n, { expression: e(je, null, { expression: n.args[0], operator: "!" }), operator: "!" }).transform(r); break; case "Function": if (b(n.args, function (n) { return n instanceof lt })) try { var o = "(function(" + n.args.slice(0, -1).map(function (n) { return n.value }).join(",") + "){" + n.args[n.args.length - 1].value + "})()", a = q(o); a.figure_out_scope({ screw_ie8: r.option("screw_ie8") }); var u = new I(r.options); a = a.transform(u), a.figure_out_scope({ screw_ie8: r.option("screw_ie8") }), a.mangle_names(); var s; try { a.walk(new E(function (n) { if (n instanceof fe) throw s = n, a })) } catch (c) { if (c !== a) throw c } var l = s.argnames.map(function (t, r) { return e(lt, n.args[r], { value: t.print_to_string() }) }), o = z(); return J.prototype._codegen.call(s, s, o), o = o.toString().replace(/^\{|\}$/g, ""), l.push(e(lt, n.args[n.args.length - 1], { value: o })), n.args = l, n } catch (c) { if (!(c instanceof N)) throw console.log(c), c; r.warn("Error parsing code passed to new Function [{file}:{line},{col}]", n.args[n.args.length - 1].start), r.warn(c.toString()) } } else {
                    if (i instanceof He && "toString" == i.property && 0 == n.args.length) return e(Ie, n, { left: e(lt, n, { value: "" }), operator: "+", right: i.expression }).transform(r); if (i instanceof He && i.expression instanceof Le && "join" == i.property) {
                        var p = 0 == n.args.length ? "," : n.args[0].evaluate(r)[1];
                        if (null != p) { var d = i.expression.elements.reduce(function (n, e) { if (e = e.evaluate(r), 0 == n.length || 1 == e.length) n.push(e); else { var i = n[n.length - 1]; if (2 == i.length) { var o = "" + i[1] + p + e[1]; n[n.length - 1] = [t(r, o, i[0]), o] } else n.push(e) } return n }, []); if (0 == d.length) return e(lt, n, { value: "" }); if (1 == d.length) return d[0][0]; if ("" == p) { var h; return h = d[0][0] instanceof lt || d[1][0] instanceof lt ? d.shift()[0] : e(lt, n, { value: "" }), d.reduce(function (n, t) { return e(Ie, t[0], { operator: "+", left: n, right: t[0] }) }, h).transform(r) } var _ = n.clone(); return _.expression = _.expression.clone(), _.expression.expression = _.expression.expression.clone(), _.expression.expression.elements = d.map(function (n) { return n[0] }), f(n, _) }
                    }
                }
            } return r.option("side_effects") && n.expression instanceof pe && 0 == n.args.length && !K.prototype.has_side_effects.call(n.expression, r) ? e(mt, n).transform(r) : r.option("drop_console") && n.expression instanceof Re && n.expression.expression instanceof ut && "console" == n.expression.expression.name && n.expression.expression.undeclared() ? e(mt, n).transform(r) : n.evaluate(r)[0]
        }), n(Ne, function (n, t) { if (t.option("unsafe")) { var r = n.expression; if (r instanceof ut && r.undeclared()) switch (r.name) { case "Object": case "RegExp": case "Function": case "Error": case "Array": return e(Oe, n, n).transform(t) } } return n }), n(Me, function (n, t) { if (!t.option("side_effects")) return n; if (!n.car.has_side_effects(t)) { var r; if (!(n.cdr instanceof ut && "eval" == n.cdr.name && n.cdr.undeclared() && (r = t.parent()) instanceof Oe && r.expression === n)) return n.cdr } if (t.option("cascade")) { if (n.car instanceof Ve && !n.car.left.has_side_effects(t)) { if (n.car.left.equivalent_to(n.cdr)) return n.car; if (n.cdr instanceof Oe && n.cdr.expression.equivalent_to(n.car.left)) return n.cdr.expression = n.car, n.cdr } if (!n.car.has_side_effects(t) && !n.cdr.has_side_effects(t) && n.car.equivalent_to(n.cdr)) return n.car } return n.cdr instanceof je && "void" == n.cdr.operator && !n.cdr.expression.has_side_effects(t) ? (n.cdr.operator = n.car, n.cdr) : n.cdr instanceof mt ? e(je, n, { operator: "void", expression: n.car }) : n }), Pe.DEFMETHOD("lift_sequences", function (n) { if (n.option("sequences") && this.expression instanceof Me) { var e = this.expression, t = e.to_array(); return this.expression = t.pop(), t.push(this), e = Me.from_array(t).transform(n) } return this }), n(ze, function (n, e) { return n.lift_sequences(e) }), n(je, function (n, t) { n = n.lift_sequences(t); var r = n.expression; if (t.option("booleans") && t.in_boolean_context()) { switch (n.operator) { case "!": if (r instanceof je && "!" == r.operator) return r.expression; break; case "typeof": return t.warn("Boolean expression always true [{file}:{line},{col}]", n.start), e(wt, n) } r instanceof Ie && "!" == n.operator && (n = f(n, r.negate(t))) } return n.evaluate(t)[0] }), Ie.DEFMETHOD("lift_sequences", function (n) { if (n.option("sequences")) { if (this.left instanceof Me) { var e = this.left, t = e.to_array(); return this.left = t.pop(), t.push(this), e = Me.from_array(t).transform(n) } if (this.right instanceof Me && this instanceof Ve && !A(this.left, n)) { var e = this.right, t = e.to_array(); return this.right = t.pop(), t.push(this), e = Me.from_array(t).transform(n) } } return this }); var D = g("== === != !== * & | ^"); n(Ie, function (n, t) { var r = t.has_directive("use asm") ? l : function (e, r) { if (r || !n.left.has_side_effects(t) && !n.right.has_side_effects(t)) { e && (n.operator = e); var i = n.left; n.left = n.right, n.right = i } }; if (D(n.operator) && (n.right instanceof ft && !(n.left instanceof ft) && (n.left instanceof Ie && zt[n.left.operator] >= zt[n.operator] || r(null, !0)), /^[!=]==?$/.test(n.operator))) { if (n.left instanceof ut && n.right instanceof Ue) { if (n.right.consequent instanceof ut && n.right.consequent.definition() === n.left.definition()) { if (/^==/.test(n.operator)) return n.right.condition; if (/^!=/.test(n.operator)) return n.right.condition.negate(t) } if (n.right.alternative instanceof ut && n.right.alternative.definition() === n.left.definition()) { if (/^==/.test(n.operator)) return n.right.condition.negate(t); if (/^!=/.test(n.operator)) return n.right.condition } } if (n.right instanceof ut && n.left instanceof Ue) { if (n.left.consequent instanceof ut && n.left.consequent.definition() === n.right.definition()) { if (/^==/.test(n.operator)) return n.left.condition; if (/^!=/.test(n.operator)) return n.left.condition.negate(t) } if (n.left.alternative instanceof ut && n.left.alternative.definition() === n.right.definition()) { if (/^==/.test(n.operator)) return n.left.condition.negate(t); if (/^!=/.test(n.operator)) return n.left.condition } } } if (n = n.lift_sequences(t), t.option("comparisons")) switch (n.operator) { case "===": case "!==": (n.left.is_string(t) && n.right.is_string(t) || n.left.is_boolean() && n.right.is_boolean()) && (n.operator = n.operator.substr(0, 2)); case "==": case "!=": n.left instanceof lt && "undefined" == n.left.value && n.right instanceof je && "typeof" == n.right.operator && t.option("unsafe") && (n.right.expression instanceof ut && n.right.expression.undeclared() || (n.right = n.right.expression, n.left = e(mt, n.left).optimize(t), 2 == n.operator.length && (n.operator += "="))) } if (t.option("booleans") && t.in_boolean_context()) switch (n.operator) { case "&&": var i = n.left.evaluate(t), o = n.right.evaluate(t); if (i.length > 1 && !i[1] || o.length > 1 && !o[1]) return t.warn("Boolean && always false [{file}:{line},{col}]", n.start), e(At, n); if (i.length > 1 && i[1]) return o[0]; if (o.length > 1 && o[1]) return i[0]; break; case "||": var i = n.left.evaluate(t), o = n.right.evaluate(t); if (i.length > 1 && i[1] || o.length > 1 && o[1]) return t.warn("Boolean || always true [{file}:{line},{col}]", n.start), e(wt, n); if (i.length > 1 && !i[1]) return o[0]; if (o.length > 1 && !o[1]) return i[0]; break; case "+": var i = n.left.evaluate(t), o = n.right.evaluate(t); if (i.length > 1 && i[0] instanceof lt && i[1] || o.length > 1 && o[0] instanceof lt && o[1]) return t.warn("+ in boolean context always true [{file}:{line},{col}]", n.start), e(wt, n) } if (t.option("comparisons")) { if (!(t.parent() instanceof Ie) || t.parent() instanceof Ve) { var a = e(je, n, { operator: "!", expression: n.negate(t) }); n = f(n, a) } switch (n.operator) { case "<": r(">"); break; case "<=": r(">=") } } return "+" == n.operator && n.right instanceof lt && "" === n.right.getValue() && n.left instanceof Ie && "+" == n.left.operator && n.left.is_string(t) ? n.left : (t.option("evaluate") && "+" == n.operator && (n.left instanceof ft && n.right instanceof Ie && "+" == n.right.operator && n.right.left instanceof ft && n.right.is_string(t) && (n = e(Ie, n, { operator: "+", left: e(lt, null, { value: "" + n.left.getValue() + n.right.left.getValue(), start: n.left.start, end: n.right.left.end }), right: n.right.right })), n.right instanceof ft && n.left instanceof Ie && "+" == n.left.operator && n.left.right instanceof ft && n.left.is_string(t) && (n = e(Ie, n, { operator: "+", left: n.left.left, right: e(lt, null, { value: "" + n.left.right.getValue() + n.right.getValue(), start: n.left.right.start, end: n.right.end }) })), n.left instanceof Ie && "+" == n.left.operator && n.left.is_string(t) && n.left.right instanceof ft && n.right instanceof Ie && "+" == n.right.operator && n.right.left instanceof ft && n.right.is_string(t) && (n = e(Ie, n, { operator: "+", left: e(Ie, n.left, { operator: "+", left: n.left.left, right: e(lt, null, { value: "" + n.left.right.getValue() + n.right.left.getValue(), start: n.left.right.start, end: n.right.left.end }) }), right: n.right.right }))), n.right instanceof Ie && n.right.operator == n.operator && ("*" == n.operator || "&&" == n.operator || "||" == n.operator) ? (n.left = e(Ie, n.left, { operator: n.operator, left: n.left, right: n.right.left }), n.right = n.right.right, n.transform(t)) : n.evaluate(t)[0]) }), n(ut, function (n, r) { if (n.undeclared()) { var i = r.option("global_defs"); if (i && i.hasOwnProperty(n.name)) return t(r, i[n.name], n); switch (n.name) { case "undefined": return e(mt, n); case "NaN": return e(vt, n); case "Infinity": return e(bt, n) } } return n }), n(mt, function (n, t) { if (t.option("unsafe")) { var r = t.find_parent(se), i = r.find_variable("undefined"); if (i) { var o = e(ut, n, { name: "undefined", scope: r, thedef: i }); return o.reference(), o } } return n }); var F = ["+", "-", "/", "*", "%", ">>", "<<", ">>>", "|", "^", "&"]; n(Ve, function (n, e) { return n = n.lift_sequences(e), "=" == n.operator && n.left instanceof ut && n.right instanceof Ie && n.right.left instanceof ut && n.right.left.name == n.left.name && o(n.right.operator, F) && (n.operator = n.right.operator + "=", n.right = n.right.right), n }), n(Ue, function (n, t) { if (!t.option("conditionals")) return n; if (n.condition instanceof Me) { var r = n.condition.car; return n.condition = n.condition.cdr, Me.cons(r, n) } var i = n.condition.evaluate(t); if (i.length > 1) return i[1] ? (t.warn("Condition always true [{file}:{line},{col}]", n.start), n.consequent) : (t.warn("Condition always false [{file}:{line},{col}]", n.start), n.alternative); var o = i[0].negate(t); f(i[0], o) === o && (n = e(Ue, n, { condition: o, consequent: n.alternative, alternative: n.consequent })); var a = n.consequent, u = n.alternative; if (a instanceof Ve && u instanceof Ve && a.operator == u.operator && a.left.equivalent_to(u.left)) return e(Ve, n, { operator: a.operator, left: a.left, right: e(Ue, n, { condition: n.condition, consequent: a.right, alternative: u.right }) }); if (a instanceof Oe && u.TYPE === a.TYPE && a.args.length == u.args.length && a.expression.equivalent_to(u.expression)) { if (0 == a.args.length) return e(Me, n, { car: n.condition, cdr: a }); if (1 == a.args.length) return a.args[0] = e(Ue, n, { condition: n.condition, consequent: a.args[0], alternative: u.args[0] }), a } return a instanceof Ue && a.alternative.equivalent_to(u) ? e(Ue, n, { condition: e(Ie, n, { left: n.condition, operator: "&&", right: a.condition }), consequent: a.consequent, alternative: u }) : n }), n(yt, function (n, t) { if (t.option("booleans")) { var r = t.parent(); return r instanceof Ie && ("==" == r.operator || "!=" == r.operator) ? (t.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", { operator: r.operator, value: n.value, file: r.start.file, line: r.start.line, col: r.start.col }), e(pt, n, { value: +n.value })) : e(je, n, { operator: "!", expression: e(pt, n, { value: 1 - n.value }) }) } return n }), n(qe, function (n, t) { var r = n.property; if (r instanceof lt && t.option("properties")) { if (r = r.getValue(), Ft(r) ? t.option("screw_ie8") : $(r)) return e(He, n, { expression: n.expression, property: r }); var i = parseFloat(r); isNaN(i) || i.toString() != r || (n.property = e(pt, n.property, { value: i })) } return n }), n(Le, w), n(We, w), n(dt, w)
    }(), n.array_to_hash = t, n.slice = r, n.characters = i, n.member = o, n.find_if = a, n.repeat_string = u, n.DefaultsError = s, n.defaults = c, n.merge = f, n.noop = l, n.MAP = U, n.push_uniq = p, n.string_template = d, n.remove = h, n.mergeSort = _, n.set_difference = v, n.set_intersection = m, n.makePredicate = g, n.all = b, n.Dictionary = y, n.DEFNODE = A, n.AST_Token = V, n.AST_Node = L, n.AST_Statement = W, n.AST_Debugger = Y, n.AST_Directive = X, n.AST_SimpleStatement = G, n.walk_body = w, n.AST_Block = K, n.AST_BlockStatement = J, n.AST_EmptyStatement = Q, n.AST_StatementWithBody = Z, n.AST_LabeledStatement = ne, n.AST_IterationStatement = ee, n.AST_DWLoop = te, n.AST_Do = re, n.AST_While = ie, n.AST_For = oe, n.AST_ForIn = ae, n.AST_With = ue, n.AST_Scope = se, n.AST_Toplevel = ce, n.AST_Lambda = fe, n.AST_Accessor = le, n.AST_Function = pe, n.AST_Defun = de, n.AST_Jump = he, n.AST_Exit = _e, n.AST_Return = ve, n.AST_Throw = me, n.AST_LoopControl = ge, n.AST_Break = be, n.AST_Continue = ye, n.AST_If = Ae, n.AST_Switch = we, n.AST_SwitchBranch = Ee, n.AST_Default = De, n.AST_Case = Fe, n.AST_Try = Ce, n.AST_Catch = Se, n.AST_Finally = ke, n.AST_Definitions = Be, n.AST_Var = xe, n.AST_Const = Te, n.AST_VarDef = $e, n.AST_Call = Oe, n.AST_New = Ne, n.AST_Seq = Me, n.AST_PropAccess = Re, n.AST_Dot = He, n.AST_Sub = qe, n.AST_Unary = Pe, n.AST_UnaryPrefix = je, n.AST_UnaryPostfix = ze, n.AST_Binary = Ie, n.AST_Conditional = Ue, n.AST_Assign = Ve, n.AST_Array = Le, n.AST_Object = We, n.AST_ObjectProperty = Ye, n.AST_ObjectKeyVal = Xe, n.AST_ObjectSetter = Ge, n.AST_ObjectGetter = Ke, n.AST_Symbol = Je, n.AST_SymbolAccessor = Qe, n.AST_SymbolDeclaration = Ze, n.AST_SymbolVar = nt, n.AST_SymbolConst = et, n.AST_SymbolFunarg = tt, n.AST_SymbolDefun = rt, n.AST_SymbolLambda = it, n.AST_SymbolCatch = ot, n.AST_Label = at, n.AST_SymbolRef = ut, n.AST_LabelRef = st, n.AST_This = ct, n.AST_Constant = ft, n.AST_String = lt, n.AST_Number = pt, n.AST_RegExp = dt, n.AST_Atom = ht, n.AST_Null = _t, n.AST_NaN = vt, n.AST_Undefined = mt, n.AST_Hole = gt, n.AST_Infinity = bt, n.AST_Boolean = yt, n.AST_False = At, n.AST_True = wt, n.TreeWalker = E, n.KEYWORDS = Et, n.KEYWORDS_ATOM = Dt, n.RESERVED_WORDS = Ft, n.KEYWORDS_BEFORE_EXPRESSION = Ct, n.OPERATOR_CHARS = St, n.RE_HEX_NUMBER = kt, n.RE_OCT_NUMBER = Bt, n.RE_DEC_NUMBER = xt, n.OPERATORS = Tt, n.WHITESPACE_CHARS = $t, n.PUNC_BEFORE_EXPRESSION = Ot, n.PUNC_CHARS = Nt, n.REGEXP_MODIFIERS = Mt, n.UNICODE = Rt, n.is_letter = D, n.is_digit = F, n.is_alphanumeric_char = C, n.is_unicode_combining_mark = S, n.is_unicode_connector_punctuation = k, n.is_identifier = B, n.is_identifier_start = x, n.is_identifier_char = T, n.is_identifier_string = $, n.parse_js_number = O, n.JS_Parse_Error = N, n.js_error = M, n.is_token = R, n.EX_EOF = Ht, n.tokenizer = H, n.UNARY_PREFIX = qt, n.UNARY_POSTFIX = Pt, n.ASSIGNMENT = jt, n.PRECEDENCE = zt, n.STATEMENTS_WITH_LABELS = It, n.ATOMIC_START_TOKEN = Ut, n.parse = q, n.TreeTransformer = P, n.SymbolDef = j, n.base54 = Vt, n.OutputStream = z, n.Compressor = I
}({}, function () { return this }());